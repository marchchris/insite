{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parsePackageVersion = exports.supportsRetryableWrites = exports.enumToString = exports.emitWarningOnce = exports.emitWarning = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.deepCopy = exports.isRecord = exports.setDifference = exports.isSuperset = exports.resolveOptions = exports.hasAtomicOperators = exports.makeInterruptibleAsyncInterval = exports.calculateDurationInMs = exports.now = exports.makeClientMetadata = exports.makeStateMachine = exports.errorStrictEqual = exports.arrayStrictEqual = exports.eachAsyncSeries = exports.eachAsync = exports.collationNotSupported = exports.maxWireVersion = exports.uuidV4 = exports.databaseNamespace = exports.maybePromise = exports.makeCounter = exports.MongoDBNamespace = exports.ns = exports.deprecateOptions = exports.defaultMsgHandler = exports.getTopology = exports.decorateWithExplain = exports.decorateWithReadConcern = exports.decorateWithCollation = exports.isPromiseLike = exports.applyWriteConcern = exports.applyRetryableWrites = exports.executeLegacyOperation = exports.filterOptions = exports.mergeOptions = exports.isObject = exports.parseIndexOptions = exports.normalizeHintField = exports.checkCollectionName = exports.MAX_JS_INT = void 0;\nconst os = require(\"os\");\nconst crypto = require(\"crypto\");\nconst promise_provider_1 = require(\"./promise_provider\");\nconst error_1 = require(\"./error\");\nconst write_concern_1 = require(\"./write_concern\");\nconst common_1 = require(\"./sdam/common\");\nconst read_concern_1 = require(\"./read_concern\");\nconst bson_1 = require(\"./bson\");\nconst read_preference_1 = require(\"./read_preference\");\nconst url_1 = require(\"url\");\nconst constants_1 = require(\"./cmap/wire_protocol/constants\");\nexports.MAX_JS_INT = Number.MAX_SAFE_INTEGER + 1;\n/**\n * Throws if collectionName is not a valid mongodb collection namespace.\n * @internal\n */\nfunction checkCollectionName(collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw new error_1.MongoInvalidArgumentError('Collection name must be a String');\n  }\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new error_1.MongoInvalidArgumentError('Collection names cannot be empty');\n  }\n  if (collectionName.indexOf('$') !== -1 && collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError(\"Collection names must not contain '$'\");\n  }\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError(\"Collection names must not start or end with '.'\");\n  }\n  // Validate that we are not passing 0x00 in the collection name\n  if (collectionName.indexOf('\\x00') !== -1) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError('Collection names cannot contain a null character');\n  }\n}\nexports.checkCollectionName = checkCollectionName;\n/**\n * Ensure Hint field is in a shape we expect:\n * - object of index names mapping to 1 or -1\n * - just an index name\n * @internal\n */\nfunction normalizeHintField(hint) {\n  let finalHint = undefined;\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n    hint.forEach(param => {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {};\n    for (const name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n  return finalHint;\n}\nexports.normalizeHintField = normalizeHintField;\n/**\n * Create an index specifier based on\n * @internal\n */\nfunction parseIndexOptions(indexSpec) {\n  const fieldHash = {};\n  const indexes = [];\n  let keys;\n  // Get all the fields accordingly\n  if ('string' === typeof indexSpec) {\n    // 'type'\n    indexes.push(indexSpec + '_' + 1);\n    fieldHash[indexSpec] = 1;\n  } else if (Array.isArray(indexSpec)) {\n    indexSpec.forEach(f => {\n      if ('string' === typeof f) {\n        // [{location:'2d'}, 'type']\n        indexes.push(f + '_' + 1);\n        fieldHash[f] = 1;\n      } else if (Array.isArray(f)) {\n        // [['location', '2d'],['type', 1]]\n        indexes.push(f[0] + '_' + (f[1] || 1));\n        fieldHash[f[0]] = f[1] || 1;\n      } else if (isObject(f)) {\n        // [{location:'2d'}, {type:1}]\n        keys = Object.keys(f);\n        keys.forEach(k => {\n          indexes.push(k + '_' + f[k]);\n          fieldHash[k] = f[k];\n        });\n      } else {\n        // undefined (ignore)\n      }\n    });\n  } else if (isObject(indexSpec)) {\n    // {location:'2d', type:1}\n    keys = Object.keys(indexSpec);\n    Object.entries(indexSpec).forEach(([key, value]) => {\n      indexes.push(key + '_' + value);\n      fieldHash[key] = value;\n    });\n  }\n  return {\n    name: indexes.join('_'),\n    keys: keys,\n    fieldHash: fieldHash\n  };\n}\nexports.parseIndexOptions = parseIndexOptions;\n/**\n * Checks if arg is an Object:\n * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isObject(arg) {\n  return '[object Object]' === Object.prototype.toString.call(arg);\n}\nexports.isObject = isObject;\n/** @internal */\nfunction mergeOptions(target, source) {\n  return {\n    ...target,\n    ...source\n  };\n}\nexports.mergeOptions = mergeOptions;\n/** @internal */\nfunction filterOptions(options, names) {\n  const filterOptions = {};\n  for (const name in options) {\n    if (names.includes(name)) {\n      filterOptions[name] = options[name];\n    }\n  }\n  // Filtered options\n  return filterOptions;\n}\nexports.filterOptions = filterOptions;\n/**\n * Executes the given operation with provided arguments.\n *\n * @remarks\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @internal\n *\n * @param topology - The topology to execute this operation on\n * @param operation - The operation to execute\n * @param args - Arguments to apply the provided operation\n * @param options - Options that modify the behavior of the method\n */\nfunction executeLegacyOperation(topology, operation, args, options) {\n  const Promise = promise_provider_1.PromiseProvider.get();\n  if (!Array.isArray(args)) {\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError('This method requires an array of arguments to apply');\n  }\n  options = options !== null && options !== void 0 ? options : {};\n  let callback = args[args.length - 1];\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session;\n  let opOptions;\n  let owner;\n  if (!options.skipSessions && topology.hasSessionSupport()) {\n    opOptions = args[args.length - 2];\n    if (opOptions == null || opOptions.session == null) {\n      owner = Symbol();\n      session = topology.startSession({\n        owner\n      });\n      const optionsIndex = args.length - 2;\n      args[optionsIndex] = Object.assign({}, args[optionsIndex], {\n        session: session\n      });\n    } else if (opOptions.session && opOptions.session.hasEnded) {\n      throw new error_1.MongoExpiredSessionError();\n    }\n  }\n  function makeExecuteCallback(resolve, reject) {\n    return function (err, result) {\n      if (session && session.owner === owner && !(options === null || options === void 0 ? void 0 : options.returnsCursor)) {\n        session.endSession(() => {\n          delete opOptions.session;\n          if (err) return reject(err);\n          resolve(result);\n        });\n      } else {\n        if (err) return reject(err);\n        resolve(result);\n      }\n    };\n  }\n  // Execute using callback\n  if (typeof callback === 'function') {\n    callback = args.pop();\n    const handler = makeExecuteCallback(result => callback(undefined, result), err => callback(err, null));\n    args.push(handler);\n    try {\n      return operation(...args);\n    } catch (e) {\n      handler(e);\n      throw e;\n    }\n  }\n  // Return a Promise\n  if (args[args.length - 1] != null) {\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError('Final argument to `executeLegacyOperation` must be a callback');\n  }\n  return new Promise((resolve, reject) => {\n    const handler = makeExecuteCallback(resolve, reject);\n    args[args.length - 1] = handler;\n    try {\n      return operation(...args);\n    } catch (e) {\n      handler(e);\n    }\n  });\n}\nexports.executeLegacyOperation = executeLegacyOperation;\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n * @internal\n *\n * @param target - The target command to which we will apply retryWrites.\n * @param db - The database from which we can inherit a retryWrites value.\n */\nfunction applyRetryableWrites(target, db) {\n  var _a;\n  if (db && ((_a = db.s.options) === null || _a === void 0 ? void 0 : _a.retryWrites)) {\n    target.retryWrites = true;\n  }\n  return target;\n}\nexports.applyRetryableWrites = applyRetryableWrites;\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n * @internal\n *\n * @param target - the target command we will be applying the write concern to\n * @param sources - sources where we can inherit default write concerns from\n * @param options - optional settings passed into a command for write concern overrides\n */\nfunction applyWriteConcern(target, sources, options) {\n  options = options !== null && options !== void 0 ? options : {};\n  const db = sources.db;\n  const coll = sources.collection;\n  if (options.session && options.session.inTransaction()) {\n    // writeConcern is not allowed within a multi-statement transaction\n    if (target.writeConcern) {\n      delete target.writeConcern;\n    }\n    return target;\n  }\n  const writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n  if (writeConcern) {\n    return Object.assign(target, {\n      writeConcern\n    });\n  }\n  if (coll && coll.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, coll.writeConcern)\n    });\n  }\n  if (db && db.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, db.writeConcern)\n    });\n  }\n  return target;\n}\nexports.applyWriteConcern = applyWriteConcern;\n/**\n * Checks if a given value is a Promise\n *\n * @typeParam T - The result type of maybePromise\n * @param maybePromise - An object that could be a promise\n * @returns true if the provided value is a Promise\n */\nfunction isPromiseLike(maybePromise) {\n  return !!maybePromise && typeof maybePromise.then === 'function';\n}\nexports.isPromiseLike = isPromiseLike;\n/**\n * Applies collation to a given command.\n * @internal\n *\n * @param command - the command on which to apply collation\n * @param target - target of command\n * @param options - options containing collation settings\n */\nfunction decorateWithCollation(command, target, options) {\n  const capabilities = getTopology(target).capabilities;\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new error_1.MongoCompatibilityError(`Current topology does not support collation`);\n    }\n  }\n}\nexports.decorateWithCollation = decorateWithCollation;\n/**\n * Applies a read concern to a given command.\n * @internal\n *\n * @param command - the command on which to apply the read concern\n * @param coll - the parent collection of the operation calling this method\n */\nfunction decorateWithReadConcern(command, coll, options) {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n  const readConcern = Object.assign({}, command.readConcern || {});\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, {\n      readConcern: readConcern\n    });\n  }\n}\nexports.decorateWithReadConcern = decorateWithReadConcern;\n/**\n * Applies an explain to a given command.\n * @internal\n *\n * @param command - the command on which to apply the explain\n * @param options - the options containing the explain verbosity\n */\nfunction decorateWithExplain(command, explain) {\n  if (command.explain) {\n    return command;\n  }\n  return {\n    explain: command,\n    verbosity: explain.verbosity\n  };\n}\nexports.decorateWithExplain = decorateWithExplain;\n/**\n * A helper function to get the topology from a given provider. Throws\n * if the topology cannot be found.\n * @internal\n */\nfunction getTopology(provider) {\n  if (`topology` in provider && provider.topology) {\n    return provider.topology;\n  } else if ('client' in provider.s && provider.s.client.topology) {\n    return provider.s.client.topology;\n  } else if ('db' in provider.s && provider.s.db.s.client.topology) {\n    return provider.s.db.s.client.topology;\n  }\n  throw new error_1.MongoNotConnectedError('MongoClient must be connected to perform this operation');\n}\nexports.getTopology = getTopology;\n/**\n * Default message handler for generating deprecation warnings.\n * @internal\n *\n * @param name - function name\n * @param option - option name\n * @returns warning message\n */\nfunction defaultMsgHandler(name, option) {\n  return `${name} option [${option}] is deprecated and will be removed in a later version.`;\n}\nexports.defaultMsgHandler = defaultMsgHandler;\n/**\n * Deprecates a given function's options.\n * @internal\n *\n * @param this - the bound class if this is a method\n * @param config - configuration for deprecation\n * @param fn - the target function of deprecation\n * @returns modified function that warns once per deprecated option, and executes original function\n */\nfunction deprecateOptions(config, fn) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n  const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n  const optionsWarned = new Set();\n  function deprecated(...args) {\n    const options = args[config.optionsIndex];\n    // ensure options is a valid, non-empty object, otherwise short-circuit\n    if (!isObject(options) || Object.keys(options).length === 0) {\n      return fn.bind(this)(...args); // call the function, no change\n    }\n    // interrupt the function call with a warning\n    for (const deprecatedOption of config.deprecatedOptions) {\n      if (deprecatedOption in options && !optionsWarned.has(deprecatedOption)) {\n        optionsWarned.add(deprecatedOption);\n        const msg = msgHandler(config.name, deprecatedOption);\n        emitWarning(msg);\n        if (this && 'getLogger' in this) {\n          const logger = this.getLogger();\n          if (logger) {\n            logger.warn(msg);\n          }\n        }\n      }\n    }\n    return fn.bind(this)(...args);\n  }\n  // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  Object.setPrototypeOf(deprecated, fn);\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n  return deprecated;\n}\nexports.deprecateOptions = deprecateOptions;\n/** @internal */\nfunction ns(ns) {\n  return MongoDBNamespace.fromString(ns);\n}\nexports.ns = ns;\n/** @public */\nclass MongoDBNamespace {\n  /**\n   * Create a namespace object\n   *\n   * @param db - database name\n   * @param collection - collection name\n   */\n  constructor(db, collection) {\n    this.db = db;\n    this.collection = collection;\n  }\n  toString() {\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\n  }\n  withCollection(collection) {\n    return new MongoDBNamespace(this.db, collection);\n  }\n  static fromString(namespace) {\n    if (!namespace) {\n      // TODO(NODE-3483): Replace with MongoNamespaceError\n      throw new error_1.MongoRuntimeError(`Cannot parse namespace from \"${namespace}\"`);\n    }\n    const [db, ...collection] = namespace.split('.');\n    return new MongoDBNamespace(db, collection.join('.'));\n  }\n}\nexports.MongoDBNamespace = MongoDBNamespace;\n/** @internal */\nfunction* makeCounter(seed = 0) {\n  let count = seed;\n  while (true) {\n    const newCount = count;\n    count += 1;\n    yield newCount;\n  }\n}\nexports.makeCounter = makeCounter;\n/**\n * Helper function for either accepting a callback, or returning a promise\n * @internal\n *\n * @param callback - The last function argument in exposed method, controls if a Promise is returned\n * @param wrapper - A function that wraps the callback\n * @returns Returns void if a callback is supplied, else returns a Promise.\n */\nfunction maybePromise(callback, wrapper) {\n  const Promise = promise_provider_1.PromiseProvider.get();\n  let result;\n  if (typeof callback !== 'function') {\n    result = new Promise((resolve, reject) => {\n      callback = (err, res) => {\n        if (err) return reject(err);\n        resolve(res);\n      };\n    });\n  }\n  wrapper((err, res) => {\n    if (err != null) {\n      try {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        callback(err);\n      } catch (error) {\n        process.nextTick(() => {\n          throw error;\n        });\n      }\n      return;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    callback(err, res);\n  });\n  return result;\n}\nexports.maybePromise = maybePromise;\n/** @internal */\nfunction databaseNamespace(ns) {\n  return ns.split('.')[0];\n}\nexports.databaseNamespace = databaseNamespace;\n/**\n * Synchronously Generate a UUIDv4\n * @internal\n */\nfunction uuidV4() {\n  const result = crypto.randomBytes(16);\n  result[6] = result[6] & 0x0f | 0x40;\n  result[8] = result[8] & 0x3f | 0x80;\n  return result;\n}\nexports.uuidV4 = uuidV4;\n/**\n * A helper function for determining `maxWireVersion` between legacy and new topology instances\n * @internal\n */\nfunction maxWireVersion(topologyOrServer) {\n  if (topologyOrServer) {\n    if (topologyOrServer.loadBalanced) {\n      // Since we do not have a monitor, we assume the load balanced server is always\n      // pointed at the latest mongodb version. There is a risk that for on-prem\n      // deployments that don't upgrade immediately that this could alert to the\n      // application that a feature is avaiable that is actually not.\n      return constants_1.MAX_SUPPORTED_WIRE_VERSION;\n    }\n    if (topologyOrServer.ismaster) {\n      return topologyOrServer.ismaster.maxWireVersion;\n    }\n    if ('lastIsMaster' in topologyOrServer && typeof topologyOrServer.lastIsMaster === 'function') {\n      const lastIsMaster = topologyOrServer.lastIsMaster();\n      if (lastIsMaster) {\n        return lastIsMaster.maxWireVersion;\n      }\n    }\n    if (topologyOrServer.description && 'maxWireVersion' in topologyOrServer.description && topologyOrServer.description.maxWireVersion != null) {\n      return topologyOrServer.description.maxWireVersion;\n    }\n  }\n  return 0;\n}\nexports.maxWireVersion = maxWireVersion;\n/**\n * Checks that collation is supported by server.\n * @internal\n *\n * @param server - to check against\n * @param cmd - object where collation may be specified\n */\nfunction collationNotSupported(server, cmd) {\n  return cmd && cmd.collation && maxWireVersion(server) < 5;\n}\nexports.collationNotSupported = collationNotSupported;\n/**\n * Applies the function `eachFn` to each item in `arr`, in parallel.\n * @internal\n *\n * @param arr - An array of items to asynchronously iterate over\n * @param eachFn - A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\n * @param callback - The callback called after every item has been iterated\n */\nfunction eachAsync(arr, eachFn, callback) {\n  arr = arr || [];\n  let idx = 0;\n  let awaiting = 0;\n  for (idx = 0; idx < arr.length; ++idx) {\n    awaiting++;\n    eachFn(arr[idx], eachCallback);\n  }\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n  function eachCallback(err) {\n    awaiting--;\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n    }\n  }\n}\nexports.eachAsync = eachAsync;\n/** @internal */\nfunction eachAsyncSeries(arr, eachFn, callback) {\n  arr = arr || [];\n  let idx = 0;\n  let awaiting = arr.length;\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n  function eachCallback(err) {\n    idx++;\n    awaiting--;\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n      return;\n    }\n    eachFn(arr[idx], eachCallback);\n  }\n  eachFn(arr[idx], eachCallback);\n}\nexports.eachAsyncSeries = eachAsyncSeries;\n/** @internal */\nfunction arrayStrictEqual(arr, arr2) {\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n    return false;\n  }\n  return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\n}\nexports.arrayStrictEqual = arrayStrictEqual;\n/** @internal */\nfunction errorStrictEqual(lhs, rhs) {\n  if (lhs === rhs) {\n    return true;\n  }\n  if (!lhs || !rhs) {\n    return lhs === rhs;\n  }\n  if (lhs == null && rhs != null || lhs != null && rhs == null) {\n    return false;\n  }\n  if (lhs.constructor.name !== rhs.constructor.name) {\n    return false;\n  }\n  if (lhs.message !== rhs.message) {\n    return false;\n  }\n  return true;\n}\nexports.errorStrictEqual = errorStrictEqual;\n/** @internal */\nfunction makeStateMachine(stateTable) {\n  return function stateTransition(target, newState) {\n    const legalStates = stateTable[target.s.state];\n    if (legalStates && legalStates.indexOf(newState) < 0) {\n      throw new error_1.MongoRuntimeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);\n    }\n    target.emit('stateChanged', target.s.state, newState);\n    target.s.state = newState;\n  };\n}\nexports.makeStateMachine = makeStateMachine;\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst NODE_DRIVER_VERSION = require('../package.json').version;\nfunction makeClientMetadata(options) {\n  options = options !== null && options !== void 0 ? options : {};\n  const metadata = {\n    driver: {\n      name: 'nodejs',\n      version: NODE_DRIVER_VERSION\n    },\n    os: {\n      type: os.type(),\n      name: process.platform,\n      architecture: process.arch,\n      version: os.release()\n    },\n    platform: `Node.js ${process.version}, ${os.endianness()} (unified)`\n  };\n  // support optionally provided wrapping driver info\n  if (options.driverInfo) {\n    if (options.driverInfo.name) {\n      metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;\n    }\n    if (options.driverInfo.version) {\n      metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;\n    }\n    if (options.driverInfo.platform) {\n      metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;\n    }\n  }\n  if (options.appName) {\n    // MongoDB requires the appName not exceed a byte length of 128\n    const buffer = Buffer.from(options.appName);\n    metadata.application = {\n      name: buffer.byteLength > 128 ? buffer.slice(0, 128).toString('utf8') : options.appName\n    };\n  }\n  return metadata;\n}\nexports.makeClientMetadata = makeClientMetadata;\n/** @internal */\nfunction now() {\n  const hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\nexports.now = now;\n/** @internal */\nfunction calculateDurationInMs(started) {\n  if (typeof started !== 'number') {\n    throw new error_1.MongoInvalidArgumentError('Numeric value required to calculate duration');\n  }\n  const elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\nexports.calculateDurationInMs = calculateDurationInMs;\n/**\n * Creates an interval timer which is able to be woken up sooner than\n * the interval. The timer will also debounce multiple calls to wake\n * ensuring that the function is only ever called once within a minimum\n * interval window.\n * @internal\n *\n * @param fn - An async function to run on an interval, must accept a `callback` as its only parameter\n */\nfunction makeInterruptibleAsyncInterval(fn, options) {\n  let timerId;\n  let lastCallTime;\n  let lastWakeTime;\n  let stopped = false;\n  options = options !== null && options !== void 0 ? options : {};\n  const interval = options.interval || 1000;\n  const minInterval = options.minInterval || 500;\n  const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\n  const clock = typeof options.clock === 'function' ? options.clock : now;\n  function wake() {\n    const currentTime = clock();\n    const timeSinceLastWake = currentTime - lastWakeTime;\n    const timeSinceLastCall = currentTime - lastCallTime;\n    const timeUntilNextCall = interval - timeSinceLastCall;\n    lastWakeTime = currentTime;\n    // For the streaming protocol: there is nothing obviously stopping this\n    // interval from being woken up again while we are waiting \"infinitely\"\n    // for `fn` to be called again`. Since the function effectively\n    // never completes, the `timeUntilNextCall` will continue to grow\n    // negatively unbounded, so it will never trigger a reschedule here.\n    // debounce multiple calls to wake within the `minInterval`\n    if (timeSinceLastWake < minInterval) {\n      return;\n    }\n    // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n    if (timeUntilNextCall > minInterval) {\n      reschedule(minInterval);\n    }\n    // This is possible in virtualized environments like AWS Lambda where our\n    // clock is unreliable. In these cases the timer is \"running\" but never\n    // actually completes, so we want to execute immediately and then attempt\n    // to reschedule.\n    if (timeUntilNextCall < 0) {\n      executeAndReschedule();\n    }\n  }\n  function stop() {\n    stopped = true;\n    if (timerId) {\n      clearTimeout(timerId);\n      timerId = undefined;\n    }\n    lastCallTime = 0;\n    lastWakeTime = 0;\n  }\n  function reschedule(ms) {\n    if (stopped) return;\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n    timerId = setTimeout(executeAndReschedule, ms || interval);\n  }\n  function executeAndReschedule() {\n    lastWakeTime = 0;\n    lastCallTime = clock();\n    fn(err => {\n      if (err) throw err;\n      reschedule(interval);\n    });\n  }\n  if (immediate) {\n    executeAndReschedule();\n  } else {\n    lastCallTime = clock();\n    reschedule(undefined);\n  }\n  return {\n    wake,\n    stop\n  };\n}\nexports.makeInterruptibleAsyncInterval = makeInterruptibleAsyncInterval;\n/** @internal */\nfunction hasAtomicOperators(doc) {\n  if (Array.isArray(doc)) {\n    for (const document of doc) {\n      if (hasAtomicOperators(document)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  const keys = Object.keys(doc);\n  return keys.length > 0 && keys[0][0] === '$';\n}\nexports.hasAtomicOperators = hasAtomicOperators;\n/**\n * Merge inherited properties from parent into options, prioritizing values from options,\n * then values from parent.\n * @internal\n */\nfunction resolveOptions(parent, options) {\n  var _a, _b, _c;\n  const result = Object.assign({}, options, (0, bson_1.resolveBSONOptions)(options, parent));\n  // Users cannot pass a readConcern/writeConcern to operations in a transaction\n  const session = options === null || options === void 0 ? void 0 : options.session;\n  if (!(session === null || session === void 0 ? void 0 : session.inTransaction())) {\n    const readConcern = (_a = read_concern_1.ReadConcern.fromOptions(options)) !== null && _a !== void 0 ? _a : parent === null || parent === void 0 ? void 0 : parent.readConcern;\n    if (readConcern) {\n      result.readConcern = readConcern;\n    }\n    const writeConcern = (_b = write_concern_1.WriteConcern.fromOptions(options)) !== null && _b !== void 0 ? _b : parent === null || parent === void 0 ? void 0 : parent.writeConcern;\n    if (writeConcern) {\n      result.writeConcern = writeConcern;\n    }\n  }\n  const readPreference = (_c = read_preference_1.ReadPreference.fromOptions(options)) !== null && _c !== void 0 ? _c : parent === null || parent === void 0 ? void 0 : parent.readPreference;\n  if (readPreference) {\n    result.readPreference = readPreference;\n  }\n  return result;\n}\nexports.resolveOptions = resolveOptions;\nfunction isSuperset(set, subset) {\n  set = Array.isArray(set) ? new Set(set) : set;\n  subset = Array.isArray(subset) ? new Set(subset) : subset;\n  for (const elem of subset) {\n    if (!set.has(elem)) {\n      return false;\n    }\n  }\n  return true;\n}\nexports.isSuperset = isSuperset;\nfunction setDifference(setA, setB) {\n  const difference = new Set(setA);\n  for (const elem of setB) {\n    difference.delete(elem);\n  }\n  return difference;\n}\nexports.setDifference = setDifference;\nfunction isRecord(value, requiredKeys = undefined) {\n  const toString = Object.prototype.toString;\n  const hasOwnProperty = Object.prototype.hasOwnProperty;\n  const isObject = v => toString.call(v) === '[object Object]';\n  if (!isObject(value)) {\n    return false;\n  }\n  const ctor = value.constructor;\n  if (ctor && ctor.prototype) {\n    if (!isObject(ctor.prototype)) {\n      return false;\n    }\n    // Check to see if some method exists from the Object exists\n    if (!hasOwnProperty.call(ctor.prototype, 'isPrototypeOf')) {\n      return false;\n    }\n  }\n  if (requiredKeys) {\n    const keys = Object.keys(value);\n    return isSuperset(keys, requiredKeys);\n  }\n  return true;\n}\nexports.isRecord = isRecord;\n/**\n * Make a deep copy of an object\n *\n * NOTE: This is not meant to be the perfect implementation of a deep copy,\n * but instead something that is good enough for the purposes of\n * command monitoring.\n */\nfunction deepCopy(value) {\n  if (value == null) {\n    return value;\n  } else if (Array.isArray(value)) {\n    return value.map(item => deepCopy(item));\n  } else if (isRecord(value)) {\n    const res = {};\n    for (const key in value) {\n      res[key] = deepCopy(value[key]);\n    }\n    return res;\n  }\n  const ctor = value.constructor;\n  if (ctor) {\n    switch (ctor.name.toLowerCase()) {\n      case 'date':\n        return new ctor(Number(value));\n      case 'map':\n        return new Map(value);\n      case 'set':\n        return new Set(value);\n      case 'buffer':\n        return Buffer.from(value);\n    }\n  }\n  return value;\n}\nexports.deepCopy = deepCopy;\n/** @internal */\nconst kBuffers = Symbol('buffers');\n/** @internal */\nconst kLength = Symbol('length');\n/**\n * A pool of Buffers which allow you to read them as if they were one\n * @internal\n */\nclass BufferPool {\n  constructor() {\n    this[kBuffers] = [];\n    this[kLength] = 0;\n  }\n  get length() {\n    return this[kLength];\n  }\n  /** Adds a buffer to the internal buffer pool list */\n  append(buffer) {\n    this[kBuffers].push(buffer);\n    this[kLength] += buffer.length;\n  }\n  /** Returns the requested number of bytes without consuming them */\n  peek(size) {\n    return this.read(size, false);\n  }\n  /** Reads the requested number of bytes, optionally consuming them */\n  read(size, consume = true) {\n    if (typeof size !== 'number' || size < 0) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"size\" must be a non-negative number');\n    }\n    if (size > this[kLength]) {\n      return Buffer.alloc(0);\n    }\n    let result;\n    // read the whole buffer\n    if (size === this.length) {\n      result = Buffer.concat(this[kBuffers]);\n      if (consume) {\n        this[kBuffers] = [];\n        this[kLength] = 0;\n      }\n    }\n    // size is within first buffer, no need to concat\n    else if (size <= this[kBuffers][0].length) {\n      result = this[kBuffers][0].slice(0, size);\n      if (consume) {\n        this[kBuffers][0] = this[kBuffers][0].slice(size);\n        this[kLength] -= size;\n      }\n    }\n    // size is beyond first buffer, need to track and copy\n    else {\n      result = Buffer.allocUnsafe(size);\n      let idx;\n      let offset = 0;\n      let bytesToCopy = size;\n      for (idx = 0; idx < this[kBuffers].length; ++idx) {\n        let bytesCopied;\n        if (bytesToCopy > this[kBuffers][idx].length) {\n          bytesCopied = this[kBuffers][idx].copy(result, offset, 0);\n          offset += bytesCopied;\n        } else {\n          bytesCopied = this[kBuffers][idx].copy(result, offset, 0, bytesToCopy);\n          if (consume) {\n            this[kBuffers][idx] = this[kBuffers][idx].slice(bytesCopied);\n          }\n          offset += bytesCopied;\n          break;\n        }\n        bytesToCopy -= bytesCopied;\n      }\n      // compact the internal buffer array\n      if (consume) {\n        this[kBuffers] = this[kBuffers].slice(idx);\n        this[kLength] -= size;\n      }\n    }\n    return result;\n  }\n}\nexports.BufferPool = BufferPool;\n/** @public */\nclass HostAddress {\n  constructor(hostString) {\n    const escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts\n    const {\n      hostname,\n      port\n    } = new url_1.URL(`mongodb://${escapedHost}`);\n    if (hostname.endsWith('.sock')) {\n      // heuristically determine if we're working with a domain socket\n      this.socketPath = decodeURIComponent(hostname);\n    } else if (typeof hostname === 'string') {\n      this.isIPv6 = false;\n      let normalized = decodeURIComponent(hostname).toLowerCase();\n      if (normalized.startsWith('[') && normalized.endsWith(']')) {\n        this.isIPv6 = true;\n        normalized = normalized.substring(1, hostname.length - 1);\n      }\n      this.host = normalized.toLowerCase();\n      if (typeof port === 'number') {\n        this.port = port;\n      } else if (typeof port === 'string' && port !== '') {\n        this.port = Number.parseInt(port, 10);\n      } else {\n        this.port = 27017;\n      }\n      if (this.port === 0) {\n        throw new error_1.MongoParseError('Invalid port (zero) with hostname');\n      }\n    } else {\n      throw new error_1.MongoInvalidArgumentError('Either socketPath or host must be defined.');\n    }\n    Object.freeze(this);\n  }\n  /**\n   * @param ipv6Brackets - optionally request ipv6 bracket notation required for connection strings\n   */\n  toString(ipv6Brackets = false) {\n    if (typeof this.host === 'string') {\n      if (this.isIPv6 && ipv6Brackets) {\n        return `[${this.host}]:${this.port}`;\n      }\n      return `${this.host}:${this.port}`;\n    }\n    return `${this.socketPath}`;\n  }\n  static fromString(s) {\n    return new HostAddress(s);\n  }\n}\nexports.HostAddress = HostAddress;\nexports.DEFAULT_PK_FACTORY = {\n  // We prefer not to rely on ObjectId having a createPk method\n  createPk() {\n    return new bson_1.ObjectId();\n  }\n};\n/**\n * When the driver used emitWarning the code will be equal to this.\n * @public\n *\n * @example\n * ```js\n * process.on('warning', (warning) => {\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\n * })\n * ```\n */\nexports.MONGODB_WARNING_CODE = 'MONGODB DRIVER';\n/** @internal */\nfunction emitWarning(message) {\n  return process.emitWarning(message, {\n    code: exports.MONGODB_WARNING_CODE\n  });\n}\nexports.emitWarning = emitWarning;\nconst emittedWarnings = new Set();\n/**\n * Will emit a warning once for the duration of the application.\n * Uses the message to identify if it has already been emitted\n * so using string interpolation can cause multiple emits\n * @internal\n */\nfunction emitWarningOnce(message) {\n  if (!emittedWarnings.has(message)) {\n    emittedWarnings.add(message);\n    return emitWarning(message);\n  }\n}\nexports.emitWarningOnce = emitWarningOnce;\n/**\n * Takes a JS object and joins the values into a string separated by ', '\n */\nfunction enumToString(en) {\n  return Object.values(en).join(', ');\n}\nexports.enumToString = enumToString;\n/**\n * Determine if a server supports retryable writes.\n *\n * @internal\n */\nfunction supportsRetryableWrites(server) {\n  return !!server.loadBalanced || server.description.maxWireVersion >= 6 && !!server.description.logicalSessionTimeoutMinutes && server.description.type !== common_1.ServerType.Standalone;\n}\nexports.supportsRetryableWrites = supportsRetryableWrites;\nfunction parsePackageVersion({\n  version\n}) {\n  const [major, minor, patch] = version.split('.').map(n => Number.parseInt(n, 10));\n  return {\n    major,\n    minor,\n    patch\n  };\n}\nexports.parsePackageVersion = parsePackageVersion;","map":{"version":3,"names":["os","require","crypto","promise_provider_1","error_1","write_concern_1","common_1","read_concern_1","bson_1","read_preference_1","url_1","constants_1","exports","MAX_JS_INT","Number","MAX_SAFE_INTEGER","checkCollectionName","collectionName","MongoInvalidArgumentError","indexOf","match","normalizeHintField","hint","finalHint","undefined","Array","isArray","forEach","param","name","parseIndexOptions","indexSpec","fieldHash","indexes","keys","push","f","isObject","Object","k","entries","key","value","join","arg","prototype","toString","call","mergeOptions","target","source","filterOptions","options","names","includes","executeLegacyOperation","topology","operation","args","Promise","PromiseProvider","get","MongoRuntimeError","callback","length","session","opOptions","owner","skipSessions","hasSessionSupport","Symbol","startSession","optionsIndex","assign","hasEnded","MongoExpiredSessionError","makeExecuteCallback","resolve","reject","err","result","returnsCursor","endSession","pop","handler","e","applyRetryableWrites","db","_a","s","retryWrites","applyWriteConcern","sources","coll","collection","inTransaction","writeConcern","WriteConcern","fromOptions","isPromiseLike","maybePromise","then","decorateWithCollation","command","capabilities","getTopology","collation","commandsTakeCollation","MongoCompatibilityError","decorateWithReadConcern","readConcern","decorateWithExplain","explain","verbosity","provider","client","MongoNotConnectedError","defaultMsgHandler","option","deprecateOptions","config","fn","process","noDeprecation","msgHandler","optionsWarned","Set","deprecated","bind","deprecatedOption","deprecatedOptions","has","add","msg","emitWarning","logger","getLogger","warn","setPrototypeOf","ns","MongoDBNamespace","fromString","constructor","withCollection","namespace","split","makeCounter","seed","count","newCount","wrapper","res","error","nextTick","databaseNamespace","uuidV4","randomBytes","maxWireVersion","topologyOrServer","loadBalanced","MAX_SUPPORTED_WIRE_VERSION","ismaster","lastIsMaster","description","collationNotSupported","server","cmd","eachAsync","arr","eachFn","idx","awaiting","eachCallback","eachAsyncSeries","arrayStrictEqual","arr2","every","elt","errorStrictEqual","lhs","rhs","message","makeStateMachine","stateTable","stateTransition","newState","legalStates","state","emit","NODE_DRIVER_VERSION","version","makeClientMetadata","metadata","driver","type","platform","architecture","arch","release","endianness","driverInfo","appName","buffer","Buffer","from","application","byteLength","slice","now","hrtime","Math","floor","calculateDurationInMs","started","elapsed","makeInterruptibleAsyncInterval","timerId","lastCallTime","lastWakeTime","stopped","interval","minInterval","immediate","clock","wake","currentTime","timeSinceLastWake","timeSinceLastCall","timeUntilNextCall","reschedule","executeAndReschedule","stop","clearTimeout","ms","setTimeout","hasAtomicOperators","doc","document","resolveOptions","parent","resolveBSONOptions","ReadConcern","_b","readPreference","_c","ReadPreference","isSuperset","set","subset","elem","setDifference","setA","setB","difference","delete","isRecord","requiredKeys","hasOwnProperty","v","ctor","deepCopy","map","item","toLowerCase","Map","kBuffers","kLength","BufferPool","append","peek","size","read","consume","alloc","concat","allocUnsafe","offset","bytesToCopy","bytesCopied","copy","HostAddress","hostString","escapedHost","hostname","port","URL","endsWith","socketPath","decodeURIComponent","isIPv6","normalized","startsWith","substring","host","parseInt","MongoParseError","freeze","ipv6Brackets","DEFAULT_PK_FACTORY","createPk","ObjectId","MONGODB_WARNING_CODE","code","emittedWarnings","emitWarningOnce","enumToString","en","values","supportsRetryableWrites","logicalSessionTimeoutMinutes","ServerType","Standalone","parsePackageVersion","major","minor","patch","n"],"sources":["C:\\Users\\chris\\Desktop\\insite\\node_modules\\mongodb\\src\\utils.ts"],"sourcesContent":["import * as os from 'os';\nimport * as crypto from 'crypto';\nimport { PromiseProvider } from './promise_provider';\nimport {\n  AnyError,\n  MongoParseError,\n  MongoRuntimeError,\n  MongoCompatibilityError,\n  MongoNotConnectedError,\n  MongoInvalidArgumentError,\n  MongoExpiredSessionError\n} from './error';\nimport { WriteConcern, WriteConcernOptions, W } from './write_concern';\nimport type { Server } from './sdam/server';\nimport type { Topology } from './sdam/topology';\nimport { ServerType } from './sdam/common';\nimport type { Db } from './db';\nimport type { Collection } from './collection';\nimport type { OperationOptions, Hint } from './operations/operation';\nimport type { ClientSession } from './sessions';\nimport { ReadConcern } from './read_concern';\nimport type { Connection } from './cmap/connection';\nimport { Document, ObjectId, resolveBSONOptions } from './bson';\nimport type { IndexSpecification, IndexDirection } from './operations/indexes';\nimport type { Explain } from './explain';\nimport type { MongoClient } from './mongo_client';\nimport type { CommandOperationOptions, OperationParent } from './operations/command';\nimport { ReadPreference } from './read_preference';\nimport { URL } from 'url';\nimport { MAX_SUPPORTED_WIRE_VERSION } from './cmap/wire_protocol/constants';\n\n/**\n * MongoDB Driver style callback\n * @public\n */\nexport type Callback<T = any> = (error?: AnyError, result?: T) => void;\n/** @public */\nexport type CallbackWithType<E = AnyError, T0 = any> = (error?: E, result?: T0) => void;\n\nexport const MAX_JS_INT = Number.MAX_SAFE_INTEGER + 1;\n\nexport type AnyOptions = Document;\n\n/**\n * Throws if collectionName is not a valid mongodb collection namespace.\n * @internal\n */\nexport function checkCollectionName(collectionName: string): void {\n  if ('string' !== typeof collectionName) {\n    throw new MongoInvalidArgumentError('Collection name must be a String');\n  }\n\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new MongoInvalidArgumentError('Collection names cannot be empty');\n  }\n\n  if (\n    collectionName.indexOf('$') !== -1 &&\n    collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null\n  ) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new MongoInvalidArgumentError(\"Collection names must not contain '$'\");\n  }\n\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new MongoInvalidArgumentError(\"Collection names must not start or end with '.'\");\n  }\n\n  // Validate that we are not passing 0x00 in the collection name\n  if (collectionName.indexOf('\\x00') !== -1) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new MongoInvalidArgumentError('Collection names cannot contain a null character');\n  }\n}\n\n/**\n * Ensure Hint field is in a shape we expect:\n * - object of index names mapping to 1 or -1\n * - just an index name\n * @internal\n */\nexport function normalizeHintField(hint?: Hint): Hint | undefined {\n  let finalHint = undefined;\n\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n\n    hint.forEach(param => {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {} as Document;\n    for (const name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n}\n\ninterface IndexOptions {\n  name: string;\n  keys?: string[];\n  fieldHash: Document;\n}\n\n/**\n * Create an index specifier based on\n * @internal\n */\nexport function parseIndexOptions(indexSpec: IndexSpecification): IndexOptions {\n  const fieldHash: { [key: string]: IndexDirection } = {};\n  const indexes = [];\n  let keys;\n\n  // Get all the fields accordingly\n  if ('string' === typeof indexSpec) {\n    // 'type'\n    indexes.push(indexSpec + '_' + 1);\n    fieldHash[indexSpec] = 1;\n  } else if (Array.isArray(indexSpec)) {\n    indexSpec.forEach((f: any) => {\n      if ('string' === typeof f) {\n        // [{location:'2d'}, 'type']\n        indexes.push(f + '_' + 1);\n        fieldHash[f] = 1;\n      } else if (Array.isArray(f)) {\n        // [['location', '2d'],['type', 1]]\n        indexes.push(f[0] + '_' + (f[1] || 1));\n        fieldHash[f[0]] = f[1] || 1;\n      } else if (isObject(f)) {\n        // [{location:'2d'}, {type:1}]\n        keys = Object.keys(f);\n        keys.forEach(k => {\n          indexes.push(k + '_' + (f as AnyOptions)[k]);\n          fieldHash[k] = (f as AnyOptions)[k];\n        });\n      } else {\n        // undefined (ignore)\n      }\n    });\n  } else if (isObject(indexSpec)) {\n    // {location:'2d', type:1}\n    keys = Object.keys(indexSpec);\n    Object.entries(indexSpec).forEach(([key, value]) => {\n      indexes.push(key + '_' + value);\n      fieldHash[key] = value;\n    });\n  }\n\n  return {\n    name: indexes.join('_'),\n    keys: keys,\n    fieldHash: fieldHash\n  };\n}\n\n/**\n * Checks if arg is an Object:\n * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isObject(arg: unknown): arg is object {\n  return '[object Object]' === Object.prototype.toString.call(arg);\n}\n\n/** @internal */\nexport function mergeOptions<T, S>(target: T, source: S): T & S {\n  return { ...target, ...source };\n}\n\n/** @internal */\nexport function filterOptions(options: AnyOptions, names: string[]): AnyOptions {\n  const filterOptions: AnyOptions = {};\n\n  for (const name in options) {\n    if (names.includes(name)) {\n      filterOptions[name] = options[name];\n    }\n  }\n\n  // Filtered options\n  return filterOptions;\n}\n\n/**\n * Executes the given operation with provided arguments.\n *\n * @remarks\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @internal\n *\n * @param topology - The topology to execute this operation on\n * @param operation - The operation to execute\n * @param args - Arguments to apply the provided operation\n * @param options - Options that modify the behavior of the method\n */\nexport function executeLegacyOperation(\n  topology: Topology,\n  operation: (...args: any[]) => void | Promise<Document>,\n  args: any[],\n  options?: AnyOptions\n): void | Promise<any> {\n  const Promise = PromiseProvider.get();\n\n  if (!Array.isArray(args)) {\n    // TODO(NODE-3483)\n    throw new MongoRuntimeError('This method requires an array of arguments to apply');\n  }\n\n  options = options ?? {};\n\n  let callback = args[args.length - 1];\n\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session: ClientSession;\n  let opOptions: any;\n  let owner: any;\n  if (!options.skipSessions && topology.hasSessionSupport()) {\n    opOptions = args[args.length - 2];\n    if (opOptions == null || opOptions.session == null) {\n      owner = Symbol();\n      session = topology.startSession({ owner });\n      const optionsIndex = args.length - 2;\n      args[optionsIndex] = Object.assign({}, args[optionsIndex], { session: session });\n    } else if (opOptions.session && opOptions.session.hasEnded) {\n      throw new MongoExpiredSessionError();\n    }\n  }\n\n  function makeExecuteCallback(\n    resolve: (value?: Document) => void,\n    reject: (reason?: AnyError) => void\n  ) {\n    return function (err?: AnyError, result?: any) {\n      if (session && session.owner === owner && !options?.returnsCursor) {\n        session.endSession(() => {\n          delete opOptions.session;\n          if (err) return reject(err);\n          resolve(result);\n        });\n      } else {\n        if (err) return reject(err);\n        resolve(result);\n      }\n    };\n  }\n\n  // Execute using callback\n  if (typeof callback === 'function') {\n    callback = args.pop();\n    const handler = makeExecuteCallback(\n      result => callback(undefined, result),\n      err => callback(err, null)\n    );\n    args.push(handler);\n\n    try {\n      return operation(...args);\n    } catch (e) {\n      handler(e);\n      throw e;\n    }\n  }\n\n  // Return a Promise\n  if (args[args.length - 1] != null) {\n    // TODO(NODE-3483)\n    throw new MongoRuntimeError('Final argument to `executeLegacyOperation` must be a callback');\n  }\n\n  return new Promise<any>((resolve, reject) => {\n    const handler = makeExecuteCallback(resolve, reject);\n    args[args.length - 1] = handler;\n\n    try {\n      return operation(...args);\n    } catch (e) {\n      handler(e);\n    }\n  });\n}\n\ninterface HasRetryableWrites {\n  retryWrites?: boolean;\n}\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n * @internal\n *\n * @param target - The target command to which we will apply retryWrites.\n * @param db - The database from which we can inherit a retryWrites value.\n */\nexport function applyRetryableWrites<T extends HasRetryableWrites>(target: T, db?: Db): T {\n  if (db && db.s.options?.retryWrites) {\n    target.retryWrites = true;\n  }\n\n  return target;\n}\n\ninterface HasWriteConcern {\n  writeConcern?: WriteConcernOptions | WriteConcern | W;\n}\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n * @internal\n *\n * @param target - the target command we will be applying the write concern to\n * @param sources - sources where we can inherit default write concerns from\n * @param options - optional settings passed into a command for write concern overrides\n */\nexport function applyWriteConcern<T extends HasWriteConcern>(\n  target: T,\n  sources: { db?: Db; collection?: Collection },\n  options?: OperationOptions & WriteConcernOptions\n): T {\n  options = options ?? {};\n  const db = sources.db;\n  const coll = sources.collection;\n\n  if (options.session && options.session.inTransaction()) {\n    // writeConcern is not allowed within a multi-statement transaction\n    if (target.writeConcern) {\n      delete target.writeConcern;\n    }\n\n    return target;\n  }\n\n  const writeConcern = WriteConcern.fromOptions(options);\n  if (writeConcern) {\n    return Object.assign(target, { writeConcern });\n  }\n\n  if (coll && coll.writeConcern) {\n    return Object.assign(target, { writeConcern: Object.assign({}, coll.writeConcern) });\n  }\n\n  if (db && db.writeConcern) {\n    return Object.assign(target, { writeConcern: Object.assign({}, db.writeConcern) });\n  }\n\n  return target;\n}\n\n/**\n * Checks if a given value is a Promise\n *\n * @typeParam T - The result type of maybePromise\n * @param maybePromise - An object that could be a promise\n * @returns true if the provided value is a Promise\n */\nexport function isPromiseLike<T = any>(\n  maybePromise?: PromiseLike<T> | void\n): maybePromise is Promise<T> {\n  return !!maybePromise && typeof maybePromise.then === 'function';\n}\n\n/**\n * Applies collation to a given command.\n * @internal\n *\n * @param command - the command on which to apply collation\n * @param target - target of command\n * @param options - options containing collation settings\n */\nexport function decorateWithCollation(\n  command: Document,\n  target: MongoClient | Db | Collection,\n  options: AnyOptions\n): void {\n  const capabilities = getTopology(target).capabilities;\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new MongoCompatibilityError(`Current topology does not support collation`);\n    }\n  }\n}\n\n/**\n * Applies a read concern to a given command.\n * @internal\n *\n * @param command - the command on which to apply the read concern\n * @param coll - the parent collection of the operation calling this method\n */\nexport function decorateWithReadConcern(\n  command: Document,\n  coll: { s: { readConcern?: ReadConcern } },\n  options?: OperationOptions\n): void {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n  const readConcern = Object.assign({}, command.readConcern || {});\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, { readConcern: readConcern });\n  }\n}\n\n/**\n * Applies an explain to a given command.\n * @internal\n *\n * @param command - the command on which to apply the explain\n * @param options - the options containing the explain verbosity\n */\nexport function decorateWithExplain(command: Document, explain: Explain): Document {\n  if (command.explain) {\n    return command;\n  }\n\n  return { explain: command, verbosity: explain.verbosity };\n}\n\n/**\n * A helper function to get the topology from a given provider. Throws\n * if the topology cannot be found.\n * @internal\n */\nexport function getTopology<T>(provider: MongoClient | Db | Collection<T>): Topology {\n  if (`topology` in provider && provider.topology) {\n    return provider.topology;\n  } else if ('client' in provider.s && provider.s.client.topology) {\n    return provider.s.client.topology;\n  } else if ('db' in provider.s && provider.s.db.s.client.topology) {\n    return provider.s.db.s.client.topology;\n  }\n\n  throw new MongoNotConnectedError('MongoClient must be connected to perform this operation');\n}\n\n/**\n * Default message handler for generating deprecation warnings.\n * @internal\n *\n * @param name - function name\n * @param option - option name\n * @returns warning message\n */\nexport function defaultMsgHandler(name: string, option: string): string {\n  return `${name} option [${option}] is deprecated and will be removed in a later version.`;\n}\n\nexport interface DeprecateOptionsConfig {\n  /** function name */\n  name: string;\n  /** options to deprecate */\n  deprecatedOptions: string[];\n  /** index of options object in function arguments array */\n  optionsIndex: number;\n  /** optional custom message handler to generate warnings */\n  msgHandler?(name: string, option: string): string;\n}\n\n/**\n * Deprecates a given function's options.\n * @internal\n *\n * @param this - the bound class if this is a method\n * @param config - configuration for deprecation\n * @param fn - the target function of deprecation\n * @returns modified function that warns once per deprecated option, and executes original function\n */\nexport function deprecateOptions(\n  this: unknown,\n  config: DeprecateOptionsConfig,\n  fn: (...args: any[]) => any\n): any {\n  if ((process as any).noDeprecation === true) {\n    return fn;\n  }\n\n  const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n\n  const optionsWarned = new Set();\n  function deprecated(this: any, ...args: any[]) {\n    const options = args[config.optionsIndex] as AnyOptions;\n\n    // ensure options is a valid, non-empty object, otherwise short-circuit\n    if (!isObject(options) || Object.keys(options).length === 0) {\n      return fn.bind(this)(...args); // call the function, no change\n    }\n\n    // interrupt the function call with a warning\n    for (const deprecatedOption of config.deprecatedOptions) {\n      if (deprecatedOption in options && !optionsWarned.has(deprecatedOption)) {\n        optionsWarned.add(deprecatedOption);\n        const msg = msgHandler(config.name, deprecatedOption);\n        emitWarning(msg);\n        if (this && 'getLogger' in this) {\n          const logger = this.getLogger();\n          if (logger) {\n            logger.warn(msg);\n          }\n        }\n      }\n    }\n\n    return fn.bind(this)(...args);\n  }\n\n  // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  Object.setPrototypeOf(deprecated, fn);\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\n/** @internal */\nexport function ns(ns: string): MongoDBNamespace {\n  return MongoDBNamespace.fromString(ns);\n}\n\n/** @public */\nexport class MongoDBNamespace {\n  db: string;\n  collection?: string;\n  /**\n   * Create a namespace object\n   *\n   * @param db - database name\n   * @param collection - collection name\n   */\n  constructor(db: string, collection?: string) {\n    this.db = db;\n    this.collection = collection;\n  }\n\n  toString(): string {\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\n  }\n\n  withCollection(collection: string): MongoDBNamespace {\n    return new MongoDBNamespace(this.db, collection);\n  }\n\n  static fromString(namespace?: string): MongoDBNamespace {\n    if (!namespace) {\n      // TODO(NODE-3483): Replace with MongoNamespaceError\n      throw new MongoRuntimeError(`Cannot parse namespace from \"${namespace}\"`);\n    }\n\n    const [db, ...collection] = namespace.split('.');\n    return new MongoDBNamespace(db, collection.join('.'));\n  }\n}\n\n/** @internal */\nexport function* makeCounter(seed = 0): Generator<number> {\n  let count = seed;\n  while (true) {\n    const newCount = count;\n    count += 1;\n    yield newCount;\n  }\n}\n\n/**\n * Helper function for either accepting a callback, or returning a promise\n * @internal\n *\n * @param callback - The last function argument in exposed method, controls if a Promise is returned\n * @param wrapper - A function that wraps the callback\n * @returns Returns void if a callback is supplied, else returns a Promise.\n */\nexport function maybePromise<T>(\n  callback: Callback<T> | undefined,\n  wrapper: (fn: Callback<T>) => void\n): Promise<T> | void {\n  const Promise = PromiseProvider.get();\n  let result: Promise<T> | void;\n  if (typeof callback !== 'function') {\n    result = new Promise<any>((resolve, reject) => {\n      callback = (err, res) => {\n        if (err) return reject(err);\n        resolve(res);\n      };\n    });\n  }\n\n  wrapper((err, res) => {\n    if (err != null) {\n      try {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        callback!(err);\n      } catch (error) {\n        process.nextTick(() => {\n          throw error;\n        });\n      }\n\n      return;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    callback!(err, res);\n  });\n\n  return result;\n}\n\n/** @internal */\nexport function databaseNamespace(ns: string): string {\n  return ns.split('.')[0];\n}\n\n/**\n * Synchronously Generate a UUIDv4\n * @internal\n */\nexport function uuidV4(): Buffer {\n  const result = crypto.randomBytes(16);\n  result[6] = (result[6] & 0x0f) | 0x40;\n  result[8] = (result[8] & 0x3f) | 0x80;\n  return result;\n}\n\n/**\n * A helper function for determining `maxWireVersion` between legacy and new topology instances\n * @internal\n */\nexport function maxWireVersion(topologyOrServer?: Connection | Topology | Server): number {\n  if (topologyOrServer) {\n    if (topologyOrServer.loadBalanced) {\n      // Since we do not have a monitor, we assume the load balanced server is always\n      // pointed at the latest mongodb version. There is a risk that for on-prem\n      // deployments that don't upgrade immediately that this could alert to the\n      // application that a feature is avaiable that is actually not.\n      return MAX_SUPPORTED_WIRE_VERSION;\n    }\n    if (topologyOrServer.ismaster) {\n      return topologyOrServer.ismaster.maxWireVersion;\n    }\n\n    if ('lastIsMaster' in topologyOrServer && typeof topologyOrServer.lastIsMaster === 'function') {\n      const lastIsMaster = topologyOrServer.lastIsMaster();\n      if (lastIsMaster) {\n        return lastIsMaster.maxWireVersion;\n      }\n    }\n\n    if (\n      topologyOrServer.description &&\n      'maxWireVersion' in topologyOrServer.description &&\n      topologyOrServer.description.maxWireVersion != null\n    ) {\n      return topologyOrServer.description.maxWireVersion;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Checks that collation is supported by server.\n * @internal\n *\n * @param server - to check against\n * @param cmd - object where collation may be specified\n */\nexport function collationNotSupported(server: Server, cmd: Document): boolean {\n  return cmd && cmd.collation && maxWireVersion(server) < 5;\n}\n\n/**\n * Applies the function `eachFn` to each item in `arr`, in parallel.\n * @internal\n *\n * @param arr - An array of items to asynchronously iterate over\n * @param eachFn - A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\n * @param callback - The callback called after every item has been iterated\n */\nexport function eachAsync<T = Document>(\n  arr: T[],\n  eachFn: (item: T, callback: (err?: AnyError) => void) => void,\n  callback: Callback\n): void {\n  arr = arr || [];\n\n  let idx = 0;\n  let awaiting = 0;\n  for (idx = 0; idx < arr.length; ++idx) {\n    awaiting++;\n    eachFn(arr[idx], eachCallback);\n  }\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err?: AnyError) {\n    awaiting--;\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n    }\n  }\n}\n\n/** @internal */\nexport function eachAsyncSeries<T = any>(\n  arr: T[],\n  eachFn: (item: T, callback: (err?: AnyError) => void) => void,\n  callback: Callback\n): void {\n  arr = arr || [];\n\n  let idx = 0;\n  let awaiting = arr.length;\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err?: AnyError) {\n    idx++;\n    awaiting--;\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n      return;\n    }\n\n    eachFn(arr[idx], eachCallback);\n  }\n\n  eachFn(arr[idx], eachCallback);\n}\n\n/** @internal */\nexport function arrayStrictEqual(arr: unknown[], arr2: unknown[]): boolean {\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n    return false;\n  }\n\n  return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\n}\n\n/** @internal */\nexport function errorStrictEqual(lhs?: AnyError, rhs?: AnyError): boolean {\n  if (lhs === rhs) {\n    return true;\n  }\n\n  if (!lhs || !rhs) {\n    return lhs === rhs;\n  }\n\n  if ((lhs == null && rhs != null) || (lhs != null && rhs == null)) {\n    return false;\n  }\n\n  if (lhs.constructor.name !== rhs.constructor.name) {\n    return false;\n  }\n\n  if (lhs.message !== rhs.message) {\n    return false;\n  }\n\n  return true;\n}\n\ninterface StateTable {\n  [key: string]: string[];\n}\ninterface ObjectWithState {\n  s: { state: string };\n  emit(event: 'stateChanged', state: string, newState: string): void;\n}\ninterface StateTransitionFunction {\n  (target: ObjectWithState, newState: string): void;\n}\n\n/** @public */\nexport type EventEmitterWithState = {\n  /** @internal */\n  stateChanged(previous: string, current: string): void;\n};\n\n/** @internal */\nexport function makeStateMachine(stateTable: StateTable): StateTransitionFunction {\n  return function stateTransition(target, newState) {\n    const legalStates = stateTable[target.s.state];\n    if (legalStates && legalStates.indexOf(newState) < 0) {\n      throw new MongoRuntimeError(\n        `illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`\n      );\n    }\n\n    target.emit('stateChanged', target.s.state, newState);\n    target.s.state = newState;\n  };\n}\n\n/** @public */\nexport interface ClientMetadata {\n  driver: {\n    name: string;\n    version: string;\n  };\n  os: {\n    type: string;\n    name: NodeJS.Platform;\n    architecture: string;\n    version: string;\n  };\n  platform: string;\n  version?: string;\n  application?: {\n    name: string;\n  };\n}\n\n/** @public */\nexport interface ClientMetadataOptions {\n  driverInfo?: {\n    name?: string;\n    version?: string;\n    platform?: string;\n  };\n  appName?: string;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst NODE_DRIVER_VERSION = require('../package.json').version;\n\nexport function makeClientMetadata(options?: ClientMetadataOptions): ClientMetadata {\n  options = options ?? {};\n\n  const metadata: ClientMetadata = {\n    driver: {\n      name: 'nodejs',\n      version: NODE_DRIVER_VERSION\n    },\n    os: {\n      type: os.type(),\n      name: process.platform,\n      architecture: process.arch,\n      version: os.release()\n    },\n    platform: `Node.js ${process.version}, ${os.endianness()} (unified)`\n  };\n\n  // support optionally provided wrapping driver info\n  if (options.driverInfo) {\n    if (options.driverInfo.name) {\n      metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;\n    }\n\n    if (options.driverInfo.version) {\n      metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;\n    }\n\n    if (options.driverInfo.platform) {\n      metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;\n    }\n  }\n\n  if (options.appName) {\n    // MongoDB requires the appName not exceed a byte length of 128\n    const buffer = Buffer.from(options.appName);\n    metadata.application = {\n      name: buffer.byteLength > 128 ? buffer.slice(0, 128).toString('utf8') : options.appName\n    };\n  }\n\n  return metadata;\n}\n\n/** @internal */\nexport function now(): number {\n  const hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\n\n/** @internal */\nexport function calculateDurationInMs(started: number): number {\n  if (typeof started !== 'number') {\n    throw new MongoInvalidArgumentError('Numeric value required to calculate duration');\n  }\n\n  const elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\n\nexport interface InterruptibleAsyncIntervalOptions {\n  /** The interval to execute a method on */\n  interval: number;\n  /** A minimum interval that must elapse before the method is called */\n  minInterval: number;\n  /** Whether the method should be called immediately when the interval is started  */\n  immediate: boolean;\n\n  /**\n   * Only used for testing unreliable timer environments\n   * @internal\n   */\n  clock: () => number;\n}\n\n/** @internal */\nexport interface InterruptibleAsyncInterval {\n  wake(): void;\n  stop(): void;\n}\n\n/**\n * Creates an interval timer which is able to be woken up sooner than\n * the interval. The timer will also debounce multiple calls to wake\n * ensuring that the function is only ever called once within a minimum\n * interval window.\n * @internal\n *\n * @param fn - An async function to run on an interval, must accept a `callback` as its only parameter\n */\nexport function makeInterruptibleAsyncInterval(\n  fn: (callback: Callback) => void,\n  options?: Partial<InterruptibleAsyncIntervalOptions>\n): InterruptibleAsyncInterval {\n  let timerId: NodeJS.Timeout | undefined;\n  let lastCallTime: number;\n  let lastWakeTime: number;\n  let stopped = false;\n\n  options = options ?? {};\n  const interval = options.interval || 1000;\n  const minInterval = options.minInterval || 500;\n  const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\n  const clock = typeof options.clock === 'function' ? options.clock : now;\n\n  function wake() {\n    const currentTime = clock();\n    const timeSinceLastWake = currentTime - lastWakeTime;\n    const timeSinceLastCall = currentTime - lastCallTime;\n    const timeUntilNextCall = interval - timeSinceLastCall;\n    lastWakeTime = currentTime;\n\n    // For the streaming protocol: there is nothing obviously stopping this\n    // interval from being woken up again while we are waiting \"infinitely\"\n    // for `fn` to be called again`. Since the function effectively\n    // never completes, the `timeUntilNextCall` will continue to grow\n    // negatively unbounded, so it will never trigger a reschedule here.\n\n    // debounce multiple calls to wake within the `minInterval`\n    if (timeSinceLastWake < minInterval) {\n      return;\n    }\n\n    // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n    if (timeUntilNextCall > minInterval) {\n      reschedule(minInterval);\n    }\n\n    // This is possible in virtualized environments like AWS Lambda where our\n    // clock is unreliable. In these cases the timer is \"running\" but never\n    // actually completes, so we want to execute immediately and then attempt\n    // to reschedule.\n    if (timeUntilNextCall < 0) {\n      executeAndReschedule();\n    }\n  }\n\n  function stop() {\n    stopped = true;\n    if (timerId) {\n      clearTimeout(timerId);\n      timerId = undefined;\n    }\n\n    lastCallTime = 0;\n    lastWakeTime = 0;\n  }\n\n  function reschedule(ms?: number) {\n    if (stopped) return;\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n\n    timerId = setTimeout(executeAndReschedule, ms || interval);\n  }\n\n  function executeAndReschedule() {\n    lastWakeTime = 0;\n    lastCallTime = clock();\n\n    fn(err => {\n      if (err) throw err;\n      reschedule(interval);\n    });\n  }\n\n  if (immediate) {\n    executeAndReschedule();\n  } else {\n    lastCallTime = clock();\n    reschedule(undefined);\n  }\n\n  return { wake, stop };\n}\n\n/** @internal */\nexport function hasAtomicOperators(doc: Document | Document[]): boolean {\n  if (Array.isArray(doc)) {\n    for (const document of doc) {\n      if (hasAtomicOperators(document)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  const keys = Object.keys(doc);\n  return keys.length > 0 && keys[0][0] === '$';\n}\n\n/**\n * Merge inherited properties from parent into options, prioritizing values from options,\n * then values from parent.\n * @internal\n */\nexport function resolveOptions<T extends CommandOperationOptions>(\n  parent: OperationParent | undefined,\n  options?: T\n): T {\n  const result: T = Object.assign({}, options, resolveBSONOptions(options, parent));\n\n  // Users cannot pass a readConcern/writeConcern to operations in a transaction\n  const session = options?.session;\n  if (!session?.inTransaction()) {\n    const readConcern = ReadConcern.fromOptions(options) ?? parent?.readConcern;\n    if (readConcern) {\n      result.readConcern = readConcern;\n    }\n\n    const writeConcern = WriteConcern.fromOptions(options) ?? parent?.writeConcern;\n    if (writeConcern) {\n      result.writeConcern = writeConcern;\n    }\n  }\n\n  const readPreference = ReadPreference.fromOptions(options) ?? parent?.readPreference;\n  if (readPreference) {\n    result.readPreference = readPreference;\n  }\n\n  return result;\n}\n\nexport function isSuperset(set: Set<any> | any[], subset: Set<any> | any[]): boolean {\n  set = Array.isArray(set) ? new Set(set) : set;\n  subset = Array.isArray(subset) ? new Set(subset) : subset;\n  for (const elem of subset) {\n    if (!set.has(elem)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function setDifference(setA: Iterable<any>, setB: Iterable<any>): Set<any> {\n  const difference = new Set(setA);\n  for (const elem of setB) {\n    difference.delete(elem);\n  }\n  return difference;\n}\n\nexport function isRecord<T extends readonly string[]>(\n  value: unknown,\n  requiredKeys: T\n): value is Record<T[number], any>;\nexport function isRecord(value: unknown): value is Record<string, any>;\nexport function isRecord(\n  value: unknown,\n  requiredKeys: string[] | undefined = undefined\n): value is Record<string, any> {\n  const toString = Object.prototype.toString;\n  const hasOwnProperty = Object.prototype.hasOwnProperty;\n  const isObject = (v: unknown) => toString.call(v) === '[object Object]';\n  if (!isObject(value)) {\n    return false;\n  }\n\n  const ctor = (value as any).constructor;\n  if (ctor && ctor.prototype) {\n    if (!isObject(ctor.prototype)) {\n      return false;\n    }\n\n    // Check to see if some method exists from the Object exists\n    if (!hasOwnProperty.call(ctor.prototype, 'isPrototypeOf')) {\n      return false;\n    }\n  }\n\n  if (requiredKeys) {\n    const keys = Object.keys(value as Record<string, any>);\n    return isSuperset(keys, requiredKeys);\n  }\n\n  return true;\n}\n\n/**\n * Make a deep copy of an object\n *\n * NOTE: This is not meant to be the perfect implementation of a deep copy,\n * but instead something that is good enough for the purposes of\n * command monitoring.\n */\nexport function deepCopy<T extends any>(value: T): T {\n  if (value == null) {\n    return value;\n  } else if (Array.isArray(value)) {\n    return value.map(item => deepCopy(item)) as T;\n  } else if (isRecord(value)) {\n    const res = {} as any;\n    for (const key in value) {\n      res[key] = deepCopy(value[key]);\n    }\n    return res;\n  }\n\n  const ctor = (value as any).constructor;\n  if (ctor) {\n    switch (ctor.name.toLowerCase()) {\n      case 'date':\n        return new ctor(Number(value));\n      case 'map':\n        return new Map(value as any) as T;\n      case 'set':\n        return new Set(value as any) as T;\n      case 'buffer':\n        return Buffer.from(value as Buffer) as T;\n    }\n  }\n\n  return value;\n}\n\n/** @internal */\nconst kBuffers = Symbol('buffers');\n/** @internal */\nconst kLength = Symbol('length');\n\n/**\n * A pool of Buffers which allow you to read them as if they were one\n * @internal\n */\nexport class BufferPool {\n  [kBuffers]: Buffer[];\n  [kLength]: number;\n\n  constructor() {\n    this[kBuffers] = [];\n    this[kLength] = 0;\n  }\n\n  get length(): number {\n    return this[kLength];\n  }\n\n  /** Adds a buffer to the internal buffer pool list */\n  append(buffer: Buffer): void {\n    this[kBuffers].push(buffer);\n    this[kLength] += buffer.length;\n  }\n\n  /** Returns the requested number of bytes without consuming them */\n  peek(size: number): Buffer {\n    return this.read(size, false);\n  }\n\n  /** Reads the requested number of bytes, optionally consuming them */\n  read(size: number, consume = true): Buffer {\n    if (typeof size !== 'number' || size < 0) {\n      throw new MongoInvalidArgumentError('Argument \"size\" must be a non-negative number');\n    }\n\n    if (size > this[kLength]) {\n      return Buffer.alloc(0);\n    }\n\n    let result: Buffer;\n\n    // read the whole buffer\n    if (size === this.length) {\n      result = Buffer.concat(this[kBuffers]);\n\n      if (consume) {\n        this[kBuffers] = [];\n        this[kLength] = 0;\n      }\n    }\n\n    // size is within first buffer, no need to concat\n    else if (size <= this[kBuffers][0].length) {\n      result = this[kBuffers][0].slice(0, size);\n      if (consume) {\n        this[kBuffers][0] = this[kBuffers][0].slice(size);\n        this[kLength] -= size;\n      }\n    }\n\n    // size is beyond first buffer, need to track and copy\n    else {\n      result = Buffer.allocUnsafe(size);\n\n      let idx;\n      let offset = 0;\n      let bytesToCopy = size;\n      for (idx = 0; idx < this[kBuffers].length; ++idx) {\n        let bytesCopied;\n        if (bytesToCopy > this[kBuffers][idx].length) {\n          bytesCopied = this[kBuffers][idx].copy(result, offset, 0);\n          offset += bytesCopied;\n        } else {\n          bytesCopied = this[kBuffers][idx].copy(result, offset, 0, bytesToCopy);\n          if (consume) {\n            this[kBuffers][idx] = this[kBuffers][idx].slice(bytesCopied);\n          }\n          offset += bytesCopied;\n          break;\n        }\n\n        bytesToCopy -= bytesCopied;\n      }\n\n      // compact the internal buffer array\n      if (consume) {\n        this[kBuffers] = this[kBuffers].slice(idx);\n        this[kLength] -= size;\n      }\n    }\n\n    return result;\n  }\n}\n\n/** @public */\nexport class HostAddress {\n  host;\n  port;\n  // Driver only works with unix socket path to connect\n  // SDAM operates only on tcp addresses\n  socketPath;\n  isIPv6;\n\n  constructor(hostString: string) {\n    const escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts\n    const { hostname, port } = new URL(`mongodb://${escapedHost}`);\n\n    if (hostname.endsWith('.sock')) {\n      // heuristically determine if we're working with a domain socket\n      this.socketPath = decodeURIComponent(hostname);\n    } else if (typeof hostname === 'string') {\n      this.isIPv6 = false;\n\n      let normalized = decodeURIComponent(hostname).toLowerCase();\n      if (normalized.startsWith('[') && normalized.endsWith(']')) {\n        this.isIPv6 = true;\n        normalized = normalized.substring(1, hostname.length - 1);\n      }\n\n      this.host = normalized.toLowerCase();\n\n      if (typeof port === 'number') {\n        this.port = port;\n      } else if (typeof port === 'string' && port !== '') {\n        this.port = Number.parseInt(port, 10);\n      } else {\n        this.port = 27017;\n      }\n\n      if (this.port === 0) {\n        throw new MongoParseError('Invalid port (zero) with hostname');\n      }\n    } else {\n      throw new MongoInvalidArgumentError('Either socketPath or host must be defined.');\n    }\n    Object.freeze(this);\n  }\n\n  /**\n   * @param ipv6Brackets - optionally request ipv6 bracket notation required for connection strings\n   */\n  toString(ipv6Brackets = false): string {\n    if (typeof this.host === 'string') {\n      if (this.isIPv6 && ipv6Brackets) {\n        return `[${this.host}]:${this.port}`;\n      }\n      return `${this.host}:${this.port}`;\n    }\n    return `${this.socketPath}`;\n  }\n\n  static fromString(s: string): HostAddress {\n    return new HostAddress(s);\n  }\n}\n\nexport const DEFAULT_PK_FACTORY = {\n  // We prefer not to rely on ObjectId having a createPk method\n  createPk(): ObjectId {\n    return new ObjectId();\n  }\n};\n\n/**\n * When the driver used emitWarning the code will be equal to this.\n * @public\n *\n * @example\n * ```js\n * process.on('warning', (warning) => {\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\n * })\n * ```\n */\nexport const MONGODB_WARNING_CODE = 'MONGODB DRIVER' as const;\n\n/** @internal */\nexport function emitWarning(message: string): void {\n  return process.emitWarning(message, { code: MONGODB_WARNING_CODE } as any);\n}\n\nconst emittedWarnings = new Set();\n/**\n * Will emit a warning once for the duration of the application.\n * Uses the message to identify if it has already been emitted\n * so using string interpolation can cause multiple emits\n * @internal\n */\nexport function emitWarningOnce(message: string): void {\n  if (!emittedWarnings.has(message)) {\n    emittedWarnings.add(message);\n    return emitWarning(message);\n  }\n}\n\n/**\n * Takes a JS object and joins the values into a string separated by ', '\n */\nexport function enumToString(en: Record<string, unknown>): string {\n  return Object.values(en).join(', ');\n}\n\n/**\n * Determine if a server supports retryable writes.\n *\n * @internal\n */\nexport function supportsRetryableWrites(server: Server): boolean {\n  return (\n    !!server.loadBalanced ||\n    (server.description.maxWireVersion >= 6 &&\n      !!server.description.logicalSessionTimeoutMinutes &&\n      server.description.type !== ServerType.Standalone)\n  );\n}\n\nexport function parsePackageVersion({ version }: { version: string }): {\n  major: number;\n  minor: number;\n  patch: number;\n} {\n  const [major, minor, patch] = version.split('.').map((n: string) => Number.parseInt(n, 10));\n  return { major, minor, patch };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}