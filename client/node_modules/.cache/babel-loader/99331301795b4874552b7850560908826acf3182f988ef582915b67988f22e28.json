{"ast":null,"code":"import { sortModifiers, IMPORTANT_MODIFIER } from './modifier-utils.mjs';\nvar SPLIT_CLASSES_REGEX = /\\s+/;\nfunction mergeClassList(classList, configUtils) {\n  var splitModifiers = configUtils.splitModifiers,\n    getClassGroupId = configUtils.getClassGroupId,\n    getConflictingClassGroupIds = configUtils.getConflictingClassGroupIds;\n  /**\r\n   * Set of classGroupIds in following format:\r\n   * `{importantModifier}{variantModifiers}{classGroupId}`\r\n   * @example 'float'\r\n   * @example 'hover:focus:bg-color'\r\n   * @example 'md:!pr'\r\n   */\n\n  var classGroupsInConflict = new Set();\n  return classList.trim().split(SPLIT_CLASSES_REGEX).map(function (originalClassName) {\n    var _splitModifiers = splitModifiers(originalClassName),\n      modifiers = _splitModifiers.modifiers,\n      hasImportantModifier = _splitModifiers.hasImportantModifier,\n      baseClassName = _splitModifiers.baseClassName;\n    var classGroupId = getClassGroupId(baseClassName);\n    if (!classGroupId) {\n      return {\n        isTailwindClass: false,\n        originalClassName: originalClassName\n      };\n    }\n    var variantModifier = sortModifiers(modifiers).join(':');\n    var modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;\n    return {\n      isTailwindClass: true,\n      modifierId: modifierId,\n      classGroupId: classGroupId,\n      originalClassName: originalClassName\n    };\n  }).reverse() // Last class in conflict wins, so we need to filter conflicting classes in reverse order.\n  .filter(function (parsed) {\n    if (!parsed.isTailwindClass) {\n      return true;\n    }\n    var modifierId = parsed.modifierId,\n      classGroupId = parsed.classGroupId;\n    var classId = modifierId + classGroupId;\n    if (classGroupsInConflict.has(classId)) {\n      return false;\n    }\n    classGroupsInConflict.add(classId);\n    getConflictingClassGroupIds(classGroupId).forEach(function (group) {\n      return classGroupsInConflict.add(modifierId + group);\n    });\n    return true;\n  }).reverse().map(function (parsed) {\n    return parsed.originalClassName;\n  }).join(' ');\n}\nexport { mergeClassList };","map":{"version":3,"names":["SPLIT_CLASSES_REGEX","mergeClassList","classList","configUtils","splitModifiers","getClassGroupId","getConflictingClassGroupIds","classGroupsInConflict","Set","trim","split","map","originalClassName","_splitModifiers","modifiers","hasImportantModifier","baseClassName","classGroupId","isTailwindClass","variantModifier","sortModifiers","join","modifierId","IMPORTANT_MODIFIER","reverse","filter","parsed","classId","has","add","forEach","group"],"sources":["C:\\Users\\chris\\Desktop\\insite\\node_modules\\tailwind-merge\\src\\lib\\merge-classlist.ts"],"sourcesContent":["import { ConfigUtils } from './config-utils'\nimport { IMPORTANT_MODIFIER, sortModifiers } from './modifier-utils'\n\nconst SPLIT_CLASSES_REGEX = /\\s+/\n\nexport function mergeClassList(classList: string, configUtils: ConfigUtils) {\n    const { splitModifiers, getClassGroupId, getConflictingClassGroupIds } = configUtils\n\n    /**\n     * Set of classGroupIds in following format:\n     * `{importantModifier}{variantModifiers}{classGroupId}`\n     * @example 'float'\n     * @example 'hover:focus:bg-color'\n     * @example 'md:!pr'\n     */\n    const classGroupsInConflict = new Set<string>()\n\n    return (\n        classList\n            .trim()\n            .split(SPLIT_CLASSES_REGEX)\n            .map((originalClassName) => {\n                const { modifiers, hasImportantModifier, baseClassName } =\n                    splitModifiers(originalClassName)\n\n                const classGroupId = getClassGroupId(baseClassName)\n\n                if (!classGroupId) {\n                    return {\n                        isTailwindClass: false as const,\n                        originalClassName,\n                    }\n                }\n\n                const variantModifier = sortModifiers(modifiers).join(':')\n\n                const modifierId = hasImportantModifier\n                    ? variantModifier + IMPORTANT_MODIFIER\n                    : variantModifier\n\n                return {\n                    isTailwindClass: true as const,\n                    modifierId,\n                    classGroupId,\n                    originalClassName,\n                }\n            })\n            .reverse()\n            // Last class in conflict wins, so we need to filter conflicting classes in reverse order.\n            .filter((parsed) => {\n                if (!parsed.isTailwindClass) {\n                    return true\n                }\n\n                const { modifierId, classGroupId } = parsed\n\n                const classId = modifierId + classGroupId\n\n                if (classGroupsInConflict.has(classId)) {\n                    return false\n                }\n\n                classGroupsInConflict.add(classId)\n\n                getConflictingClassGroupIds(classGroupId).forEach((group) =>\n                    classGroupsInConflict.add(modifierId + group),\n                )\n\n                return true\n            })\n            .reverse()\n            .map((parsed) => parsed.originalClassName)\n            .join(' ')\n    )\n}\n"],"mappings":";AAGA,IAAMA,mBAAmB,GAAG,KAA5B;AAEgB,SAAAC,eAAeC,SAAf,EAAkCC,WAAlC,EAA0D;EACtE,IAAQC,cAAR,GAAyED,WAAzE,CAAQC,cAAR;IAAwBC,eAAxB,GAAyEF,WAAzE,CAAwBE,eAAxB;IAAyCC,2BAAzC,GAAyEH,WAAzE,CAAyCG,2BAAzC;EAEA;;;;;;AAMG;;EACH,IAAMC,qBAAqB,GAAG,IAAIC,GAAJ,EAA9B;EAEA,OACIN,SAAS,CACJO,IADL,GAEKC,KAFL,CAEWV,mBAFX,EAGKW,GAHL,CAGS,UAACC,iBAAD,EAAsB;IACvB,IACIC,eAAA,GAAAT,cAAc,CAACQ,iBAAD,CADlB;MAAQE,SAAR,GAAAD,eAAA,CAAQC,SAAR;MAAmBC,oBAAnB,GAAAF,eAAA,CAAmBE,oBAAnB;MAAyCC,aAAzC,GAAAH,eAAA,CAAyCG,aAAzC;IAGA,IAAMC,YAAY,GAAGZ,eAAe,CAACW,aAAD,CAApC;IAEA,IAAI,CAACC,YAAL,EAAmB;MACf,OAAO;QACHC,eAAe,EAAE,KADd;QAEHN,iBAAiB,EAAjBA;OAFJ;IAIH;IAED,IAAMO,eAAe,GAAGC,aAAa,CAACN,SAAD,CAAb,CAAyBO,IAAzB,CAA8B,GAA9B,CAAxB;IAEA,IAAMC,UAAU,GAAGP,oBAAoB,GACjCI,eAAe,GAAGI,kBADe,GAEjCJ,eAFN;IAIA,OAAO;MACHD,eAAe,EAAE,IADd;MAEHI,UAAU,EAAVA,UAFG;MAGHL,YAAY,EAAZA,YAHG;MAIHL,iBAAiB,EAAjBA;KAJJ;GAtBR,EA6BKY,OA7BL,EA8BI;EAAA,CACCC,MA/BL,CA+BY,UAACC,MAAD,EAAW;IACf,IAAI,CAACA,MAAM,CAACR,eAAZ,EAA6B;MACzB,OAAO,IAAP;IACH;IAED,IAAQI,UAAR,GAAqCI,MAArC,CAAQJ,UAAR;MAAoBL,YAApB,GAAqCS,MAArC,CAAoBT,YAApB;IAEA,IAAMU,OAAO,GAAGL,UAAU,GAAGL,YAA7B;IAEA,IAAIV,qBAAqB,CAACqB,GAAtB,CAA0BD,OAA1B,CAAJ,EAAwC;MACpC,OAAO,KAAP;IACH;IAEDpB,qBAAqB,CAACsB,GAAtB,CAA0BF,OAA1B;IAEArB,2BAA2B,CAACW,YAAD,CAA3B,CAA0Ca,OAA1C,CAAkD,UAACC,KAAD;MAAA,OAC9CxB,qBAAqB,CAACsB,GAAtB,CAA0BP,UAAU,GAAGS,KAAvC,CAD8C;KAAlD;IAIA,OAAO,IAAP;EACH,CAnDL,EAoDKP,OApDL,GAqDKb,GArDL,CAqDS,UAACe,MAAD;IAAA,OAAYA,MAAM,CAACd,iBAAnB;EAAA,CArDT,CAsDK,CAAAS,IAtDL,CAsDU,GAtDV,CADJ;AAyDH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}