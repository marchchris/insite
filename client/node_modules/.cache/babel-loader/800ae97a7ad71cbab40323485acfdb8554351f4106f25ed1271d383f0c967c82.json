{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = exports.connect = void 0;\nconst net = require(\"net\");\nconst tls = require(\"tls\");\nconst connection_1 = require(\"./connection\");\nconst error_1 = require(\"../error\");\nconst defaultAuthProviders_1 = require(\"./auth/defaultAuthProviders\");\nconst auth_provider_1 = require(\"./auth/auth_provider\");\nconst utils_1 = require(\"../utils\");\nconst constants_1 = require(\"./wire_protocol/constants\");\nconst bson_1 = require(\"../bson\");\nconst FAKE_MONGODB_SERVICE_ID = typeof process.env.FAKE_MONGODB_SERVICE_ID === 'string' && process.env.FAKE_MONGODB_SERVICE_ID.toLowerCase() === 'true';\nfunction connect(options, callback) {\n  makeConnection(options, (err, socket) => {\n    var _a;\n    if (err || !socket) {\n      return callback(err);\n    }\n    let ConnectionType = (_a = options.connectionType) !== null && _a !== void 0 ? _a : connection_1.Connection;\n    if (options.autoEncrypter) {\n      ConnectionType = connection_1.CryptoConnection;\n    }\n    performInitialHandshake(new ConnectionType(socket, options), options, callback);\n  });\n}\nexports.connect = connect;\nfunction checkSupportedServer(ismaster, options) {\n  var _a;\n  const serverVersionHighEnough = ismaster && (typeof ismaster.maxWireVersion === 'number' || ismaster.maxWireVersion instanceof bson_1.Int32) && ismaster.maxWireVersion >= constants_1.MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough = ismaster && (typeof ismaster.minWireVersion === 'number' || ismaster.minWireVersion instanceof bson_1.Int32) && ismaster.minWireVersion <= constants_1.MAX_SUPPORTED_WIRE_VERSION;\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n    const message = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(ismaster.minWireVersion)}, but this version of the Node.js Driver requires at most ${constants_1.MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_1.MAX_SUPPORTED_SERVER_VERSION})`;\n    return new error_1.MongoCompatibilityError(message);\n  }\n  const message = `Server at ${options.hostAddress} reports maximum wire version ${(_a = JSON.stringify(ismaster.maxWireVersion)) !== null && _a !== void 0 ? _a : 0}, but this version of the Node.js Driver requires at least ${constants_1.MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_1.MIN_SUPPORTED_SERVER_VERSION})`;\n  return new error_1.MongoCompatibilityError(message);\n}\nfunction performInitialHandshake(conn, options, _callback) {\n  const callback = function (err, ret) {\n    if (err && conn) {\n      conn.destroy();\n    }\n    _callback(err, ret);\n  };\n  const credentials = options.credentials;\n  if (credentials) {\n    if (!(credentials.mechanism === defaultAuthProviders_1.AuthMechanism.MONGODB_DEFAULT) && !defaultAuthProviders_1.AUTH_PROVIDERS.get(credentials.mechanism)) {\n      callback(new error_1.MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`));\n      return;\n    }\n  }\n  const authContext = new auth_provider_1.AuthContext(conn, credentials, options);\n  prepareHandshakeDocument(authContext, (err, handshakeDoc) => {\n    if (err || !handshakeDoc) {\n      return callback(err);\n    }\n    const handshakeOptions = Object.assign({}, options);\n    if (typeof options.connectTimeoutMS === 'number') {\n      // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n      handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\n    }\n    const start = new Date().getTime();\n    conn.command((0, utils_1.ns)('admin.$cmd'), handshakeDoc, handshakeOptions, (err, response) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      if ((response === null || response === void 0 ? void 0 : response.ok) === 0) {\n        callback(new error_1.MongoServerError(response));\n        return;\n      }\n      if ('isWritablePrimary' in response) {\n        // Provide pre-hello-style response document.\n        response.ismaster = response.isWritablePrimary;\n      }\n      if (response.helloOk) {\n        conn.helloOk = true;\n      }\n      const supportedServerErr = checkSupportedServer(response, options);\n      if (supportedServerErr) {\n        callback(supportedServerErr);\n        return;\n      }\n      if (options.loadBalanced) {\n        // TODO: Durran: Remove when server support exists. (NODE-3431)\n        if (FAKE_MONGODB_SERVICE_ID) {\n          response.serviceId = response.topologyVersion.processId;\n        }\n        if (!response.serviceId) {\n          return callback(new error_1.MongoCompatibilityError('Driver attempted to initialize in load balancing mode, ' + 'but the server does not support this mode.'));\n        }\n      }\n      // NOTE: This is metadata attached to the connection while porting away from\n      //       handshake being done in the `Server` class. Likely, it should be\n      //       relocated, or at very least restructured.\n      conn.ismaster = response;\n      conn.lastIsMasterMS = new Date().getTime() - start;\n      if (!response.arbiterOnly && credentials) {\n        // store the response on auth context\n        authContext.response = response;\n        const resolvedCredentials = credentials.resolveAuthMechanism(response);\n        const provider = defaultAuthProviders_1.AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\n        if (!provider) {\n          return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${resolvedCredentials.mechanism} defined.`));\n        }\n        provider.auth(authContext, err => {\n          if (err) return callback(err);\n          callback(undefined, conn);\n        });\n        return;\n      }\n      callback(undefined, conn);\n    });\n  });\n}\nfunction prepareHandshakeDocument(authContext, callback) {\n  const options = authContext.options;\n  const compressors = options.compressors ? options.compressors : [];\n  const {\n    serverApi\n  } = authContext.connection;\n  const handshakeDoc = {\n    [(serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) ? 'hello' : 'ismaster']: true,\n    helloOk: true,\n    client: options.metadata || (0, utils_1.makeClientMetadata)(options),\n    compression: compressors,\n    loadBalanced: options.loadBalanced\n  };\n  const credentials = authContext.credentials;\n  if (credentials) {\n    if (credentials.mechanism === defaultAuthProviders_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {\n      handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;\n      const provider = defaultAuthProviders_1.AUTH_PROVIDERS.get(defaultAuthProviders_1.AuthMechanism.MONGODB_SCRAM_SHA256);\n      if (!provider) {\n        // This auth mechanism is always present.\n        return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${defaultAuthProviders_1.AuthMechanism.MONGODB_SCRAM_SHA256} defined.`));\n      }\n      return provider.prepare(handshakeDoc, authContext, callback);\n    }\n    const provider = defaultAuthProviders_1.AUTH_PROVIDERS.get(credentials.mechanism);\n    if (!provider) {\n      return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`));\n    }\n    return provider.prepare(handshakeDoc, authContext, callback);\n  }\n  callback(undefined, handshakeDoc);\n}\n/** @public */\nexports.LEGAL_TLS_SOCKET_OPTIONS = ['ALPNProtocols', 'ca', 'cert', 'checkServerIdentity', 'ciphers', 'crl', 'ecdhCurve', 'key', 'minDHSize', 'passphrase', 'pfx', 'rejectUnauthorized', 'secureContext', 'secureProtocol', 'servername', 'session'];\n/** @public */\nexports.LEGAL_TCP_SOCKET_OPTIONS = ['family', 'hints', 'localAddress', 'localPort', 'lookup'];\nfunction parseConnectOptions(options) {\n  const hostAddress = options.hostAddress;\n  if (!hostAddress) throw new error_1.MongoInvalidArgumentError('Option \"hostAddress\" is required');\n  const result = {};\n  for (const name of exports.LEGAL_TCP_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      result[name] = options[name];\n    }\n  }\n  if (typeof hostAddress.socketPath === 'string') {\n    result.path = hostAddress.socketPath;\n    return result;\n  } else if (typeof hostAddress.host === 'string') {\n    result.host = hostAddress.host;\n    result.port = hostAddress.port;\n    return result;\n  } else {\n    // This should never happen since we set up HostAddresses\n    // But if we don't throw here the socket could hang until timeout\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);\n  }\n}\nfunction parseSslOptions(options) {\n  const result = parseConnectOptions(options);\n  // Merge in valid SSL options\n  for (const name of exports.LEGAL_TLS_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      result[name] = options[name];\n    }\n  }\n  // Set default sni servername to be the same as host\n  if (result.servername == null && result.host && !net.isIP(result.host)) {\n    result.servername = result.host;\n  }\n  return result;\n}\nconst SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'];\nconst SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);\nfunction makeConnection(options, _callback) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n  const useTLS = (_a = options.tls) !== null && _a !== void 0 ? _a : false;\n  const keepAlive = (_b = options.keepAlive) !== null && _b !== void 0 ? _b : true;\n  const socketTimeoutMS = (_d = (_c = options.socketTimeoutMS) !== null && _c !== void 0 ? _c : Reflect.get(options, 'socketTimeout')) !== null && _d !== void 0 ? _d : 0;\n  const noDelay = (_e = options.noDelay) !== null && _e !== void 0 ? _e : true;\n  const connectionTimeout = (_f = options.connectTimeoutMS) !== null && _f !== void 0 ? _f : 30000;\n  const rejectUnauthorized = (_g = options.rejectUnauthorized) !== null && _g !== void 0 ? _g : true;\n  const keepAliveInitialDelay = (_j = ((_h = options.keepAliveInitialDelay) !== null && _h !== void 0 ? _h : 120000) > socketTimeoutMS ? Math.round(socketTimeoutMS / 2) : options.keepAliveInitialDelay) !== null && _j !== void 0 ? _j : 120000;\n  let socket;\n  const callback = function (err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n    _callback(err, ret);\n  };\n  if (useTLS) {\n    const tlsSocket = tls.connect(parseSslOptions(options));\n    if (typeof tlsSocket.disableRenegotiation === 'function') {\n      tlsSocket.disableRenegotiation();\n    }\n    socket = tlsSocket;\n  } else {\n    socket = net.createConnection(parseConnectOptions(options));\n  }\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectionTimeout);\n  socket.setNoDelay(noDelay);\n  const connectEvent = useTLS ? 'secureConnect' : 'connect';\n  let cancellationHandler;\n  function errorHandler(eventName) {\n    return err => {\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n      if (cancellationHandler && options.cancellationToken) {\n        options.cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n    if (cancellationHandler && options.cancellationToken) {\n      options.cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n    if ('authorizationError' in socket) {\n      if (socket.authorizationError && rejectUnauthorized) {\n        return callback(socket.authorizationError);\n      }\n    }\n    socket.setTimeout(socketTimeoutMS);\n    callback(undefined, socket);\n  }\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n  if (options.cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    options.cancellationToken.once('cancel', cancellationHandler);\n  }\n  socket.once(connectEvent, connectHandler);\n}\nfunction connectionFailureError(type, err) {\n  switch (type) {\n    case 'error':\n      return new error_1.MongoNetworkError(err);\n    case 'timeout':\n      return new error_1.MongoNetworkTimeoutError('connection timed out');\n    case 'close':\n      return new error_1.MongoNetworkError('connection closed');\n    case 'cancel':\n      return new error_1.MongoNetworkError('connection establishment was cancelled');\n    default:\n      return new error_1.MongoNetworkError('unknown network error');\n  }\n}","map":{"version":3,"names":["net","require","tls","connection_1","error_1","defaultAuthProviders_1","auth_provider_1","utils_1","constants_1","bson_1","FAKE_MONGODB_SERVICE_ID","process","env","toLowerCase","connect","options","callback","makeConnection","err","socket","ConnectionType","_a","connectionType","Connection","autoEncrypter","CryptoConnection","performInitialHandshake","exports","checkSupportedServer","ismaster","serverVersionHighEnough","maxWireVersion","Int32","MIN_SUPPORTED_WIRE_VERSION","serverVersionLowEnough","minWireVersion","MAX_SUPPORTED_WIRE_VERSION","message","hostAddress","JSON","stringify","MAX_SUPPORTED_SERVER_VERSION","MongoCompatibilityError","MIN_SUPPORTED_SERVER_VERSION","conn","_callback","ret","destroy","credentials","mechanism","AuthMechanism","MONGODB_DEFAULT","AUTH_PROVIDERS","get","MongoInvalidArgumentError","authContext","AuthContext","prepareHandshakeDocument","handshakeDoc","handshakeOptions","Object","assign","connectTimeoutMS","socketTimeoutMS","start","Date","getTime","command","ns","response","ok","MongoServerError","isWritablePrimary","helloOk","supportedServerErr","loadBalanced","serviceId","topologyVersion","processId","lastIsMasterMS","arbiterOnly","resolvedCredentials","resolveAuthMechanism","provider","auth","undefined","compressors","serverApi","connection","version","client","metadata","makeClientMetadata","compression","username","saslSupportedMechs","source","MONGODB_SCRAM_SHA256","prepare","LEGAL_TLS_SOCKET_OPTIONS","LEGAL_TCP_SOCKET_OPTIONS","parseConnectOptions","result","name","socketPath","path","host","port","MongoRuntimeError","parseSslOptions","servername","isIP","SOCKET_ERROR_EVENT_LIST","SOCKET_ERROR_EVENTS","Set","useTLS","keepAlive","_b","_d","_c","Reflect","noDelay","_e","connectionTimeout","_f","rejectUnauthorized","_g","keepAliveInitialDelay","_j","_h","Math","round","tlsSocket","disableRenegotiation","createConnection","setKeepAlive","setTimeout","setNoDelay","connectEvent","cancellationHandler","errorHandler","eventName","forEach","event","removeAllListeners","cancellationToken","removeListener","connectHandler","connectionFailureError","authorizationError","once","type","MongoNetworkError","MongoNetworkTimeoutError"],"sources":["C:\\Users\\chris\\Desktop\\insite\\node_modules\\mongodb\\src\\cmap\\connect.ts"],"sourcesContent":["import * as net from 'net';\nimport * as tls from 'tls';\nimport { Connection, ConnectionOptions, CryptoConnection } from './connection';\nimport {\n  MongoNetworkError,\n  MongoNetworkTimeoutError,\n  AnyError,\n  MongoCompatibilityError,\n  MongoInvalidArgumentError,\n  MongoServerError,\n  MongoRuntimeError\n} from '../error';\nimport { AUTH_PROVIDERS, AuthMechanism } from './auth/defaultAuthProviders';\nimport { AuthContext } from './auth/auth_provider';\nimport { makeClientMetadata, ClientMetadata, Callback, CallbackWithType, ns } from '../utils';\nimport {\n  MAX_SUPPORTED_WIRE_VERSION,\n  MAX_SUPPORTED_SERVER_VERSION,\n  MIN_SUPPORTED_WIRE_VERSION,\n  MIN_SUPPORTED_SERVER_VERSION\n} from './wire_protocol/constants';\nimport type { Document } from '../bson';\nimport { Int32 } from '../bson';\n\nimport type { Socket, SocketConnectOpts } from 'net';\nimport type { TLSSocket, ConnectionOptions as TLSConnectionOpts } from 'tls';\n\nconst FAKE_MONGODB_SERVICE_ID =\n  typeof process.env.FAKE_MONGODB_SERVICE_ID === 'string' &&\n  process.env.FAKE_MONGODB_SERVICE_ID.toLowerCase() === 'true';\n\n/** @public */\nexport type Stream = Socket | TLSSocket;\n\nexport function connect(options: ConnectionOptions, callback: Callback<Connection>): void {\n  makeConnection(options, (err, socket) => {\n    if (err || !socket) {\n      return callback(err);\n    }\n\n    let ConnectionType = options.connectionType ?? Connection;\n    if (options.autoEncrypter) {\n      ConnectionType = CryptoConnection;\n    }\n    performInitialHandshake(new ConnectionType(socket, options), options, callback);\n  });\n}\n\nfunction checkSupportedServer(ismaster: Document, options: ConnectionOptions) {\n  const serverVersionHighEnough =\n    ismaster &&\n    (typeof ismaster.maxWireVersion === 'number' || ismaster.maxWireVersion instanceof Int32) &&\n    ismaster.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough =\n    ismaster &&\n    (typeof ismaster.minWireVersion === 'number' || ismaster.minWireVersion instanceof Int32) &&\n    ismaster.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;\n\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n\n    const message = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(\n      ismaster.minWireVersion\n    )}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n    return new MongoCompatibilityError(message);\n  }\n\n  const message = `Server at ${options.hostAddress} reports maximum wire version ${\n    JSON.stringify(ismaster.maxWireVersion) ?? 0\n  }, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;\n  return new MongoCompatibilityError(message);\n}\n\nfunction performInitialHandshake(\n  conn: Connection,\n  options: ConnectionOptions,\n  _callback: Callback\n) {\n  const callback: Callback<Document> = function (err, ret) {\n    if (err && conn) {\n      conn.destroy();\n    }\n    _callback(err, ret);\n  };\n\n  const credentials = options.credentials;\n  if (credentials) {\n    if (\n      !(credentials.mechanism === AuthMechanism.MONGODB_DEFAULT) &&\n      !AUTH_PROVIDERS.get(credentials.mechanism)\n    ) {\n      callback(\n        new MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`)\n      );\n      return;\n    }\n  }\n\n  const authContext = new AuthContext(conn, credentials, options);\n  prepareHandshakeDocument(authContext, (err, handshakeDoc) => {\n    if (err || !handshakeDoc) {\n      return callback(err);\n    }\n\n    const handshakeOptions: Document = Object.assign({}, options);\n    if (typeof options.connectTimeoutMS === 'number') {\n      // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n      handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\n    }\n\n    const start = new Date().getTime();\n    conn.command(ns('admin.$cmd'), handshakeDoc, handshakeOptions, (err, response) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      if (response?.ok === 0) {\n        callback(new MongoServerError(response));\n        return;\n      }\n\n      if ('isWritablePrimary' in response) {\n        // Provide pre-hello-style response document.\n        response.ismaster = response.isWritablePrimary;\n      }\n\n      if (response.helloOk) {\n        conn.helloOk = true;\n      }\n\n      const supportedServerErr = checkSupportedServer(response, options);\n      if (supportedServerErr) {\n        callback(supportedServerErr);\n        return;\n      }\n\n      if (options.loadBalanced) {\n        // TODO: Durran: Remove when server support exists. (NODE-3431)\n        if (FAKE_MONGODB_SERVICE_ID) {\n          response.serviceId = response.topologyVersion.processId;\n        }\n        if (!response.serviceId) {\n          return callback(\n            new MongoCompatibilityError(\n              'Driver attempted to initialize in load balancing mode, ' +\n                'but the server does not support this mode.'\n            )\n          );\n        }\n      }\n\n      // NOTE: This is metadata attached to the connection while porting away from\n      //       handshake being done in the `Server` class. Likely, it should be\n      //       relocated, or at very least restructured.\n      conn.ismaster = response;\n      conn.lastIsMasterMS = new Date().getTime() - start;\n\n      if (!response.arbiterOnly && credentials) {\n        // store the response on auth context\n        authContext.response = response;\n\n        const resolvedCredentials = credentials.resolveAuthMechanism(response);\n        const provider = AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\n        if (!provider) {\n          return callback(\n            new MongoInvalidArgumentError(\n              `No AuthProvider for ${resolvedCredentials.mechanism} defined.`\n            )\n          );\n        }\n        provider.auth(authContext, err => {\n          if (err) return callback(err);\n          callback(undefined, conn);\n        });\n\n        return;\n      }\n\n      callback(undefined, conn);\n    });\n  });\n}\n\nexport interface HandshakeDocument extends Document {\n  ismaster?: boolean;\n  hello?: boolean;\n  helloOk?: boolean;\n  client: ClientMetadata;\n  compression: string[];\n  saslSupportedMechs?: string;\n  loadBalanced: boolean;\n}\n\nfunction prepareHandshakeDocument(authContext: AuthContext, callback: Callback<HandshakeDocument>) {\n  const options = authContext.options;\n  const compressors = options.compressors ? options.compressors : [];\n  const { serverApi } = authContext.connection;\n\n  const handshakeDoc: HandshakeDocument = {\n    [serverApi?.version ? 'hello' : 'ismaster']: true,\n    helloOk: true,\n    client: options.metadata || makeClientMetadata(options),\n    compression: compressors,\n    loadBalanced: options.loadBalanced\n  };\n\n  const credentials = authContext.credentials;\n  if (credentials) {\n    if (credentials.mechanism === AuthMechanism.MONGODB_DEFAULT && credentials.username) {\n      handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;\n\n      const provider = AUTH_PROVIDERS.get(AuthMechanism.MONGODB_SCRAM_SHA256);\n      if (!provider) {\n        // This auth mechanism is always present.\n        return callback(\n          new MongoInvalidArgumentError(\n            `No AuthProvider for ${AuthMechanism.MONGODB_SCRAM_SHA256} defined.`\n          )\n        );\n      }\n      return provider.prepare(handshakeDoc, authContext, callback);\n    }\n    const provider = AUTH_PROVIDERS.get(credentials.mechanism);\n    if (!provider) {\n      return callback(\n        new MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`)\n      );\n    }\n    return provider.prepare(handshakeDoc, authContext, callback);\n  }\n  callback(undefined, handshakeDoc);\n}\n\n/** @public */\nexport const LEGAL_TLS_SOCKET_OPTIONS = [\n  'ALPNProtocols',\n  'ca',\n  'cert',\n  'checkServerIdentity',\n  'ciphers',\n  'crl',\n  'ecdhCurve',\n  'key',\n  'minDHSize',\n  'passphrase',\n  'pfx',\n  'rejectUnauthorized',\n  'secureContext',\n  'secureProtocol',\n  'servername',\n  'session'\n] as const;\n\n/** @public */\nexport const LEGAL_TCP_SOCKET_OPTIONS = [\n  'family',\n  'hints',\n  'localAddress',\n  'localPort',\n  'lookup'\n] as const;\n\nfunction parseConnectOptions(options: ConnectionOptions): SocketConnectOpts {\n  const hostAddress = options.hostAddress;\n  if (!hostAddress) throw new MongoInvalidArgumentError('Option \"hostAddress\" is required');\n\n  const result: Partial<net.TcpNetConnectOpts & net.IpcNetConnectOpts> = {};\n  for (const name of LEGAL_TCP_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      (result as Document)[name] = options[name];\n    }\n  }\n\n  if (typeof hostAddress.socketPath === 'string') {\n    result.path = hostAddress.socketPath;\n    return result as net.IpcNetConnectOpts;\n  } else if (typeof hostAddress.host === 'string') {\n    result.host = hostAddress.host;\n    result.port = hostAddress.port;\n    return result as net.TcpNetConnectOpts;\n  } else {\n    // This should never happen since we set up HostAddresses\n    // But if we don't throw here the socket could hang until timeout\n    // TODO(NODE-3483)\n    throw new MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);\n  }\n}\n\nfunction parseSslOptions(options: ConnectionOptions): TLSConnectionOpts {\n  const result: TLSConnectionOpts = parseConnectOptions(options);\n  // Merge in valid SSL options\n  for (const name of LEGAL_TLS_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      (result as Document)[name] = options[name];\n    }\n  }\n\n  // Set default sni servername to be the same as host\n  if (result.servername == null && result.host && !net.isIP(result.host)) {\n    result.servername = result.host;\n  }\n\n  return result;\n}\n\nconst SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'] as const;\ntype ErrorHandlerEventName = typeof SOCKET_ERROR_EVENT_LIST[number] | 'cancel';\nconst SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);\n\nfunction makeConnection(options: ConnectionOptions, _callback: CallbackWithType<AnyError, Stream>) {\n  const useTLS = options.tls ?? false;\n  const keepAlive = options.keepAlive ?? true;\n  const socketTimeoutMS = options.socketTimeoutMS ?? Reflect.get(options, 'socketTimeout') ?? 0;\n  const noDelay = options.noDelay ?? true;\n  const connectionTimeout = options.connectTimeoutMS ?? 30000;\n  const rejectUnauthorized = options.rejectUnauthorized ?? true;\n  const keepAliveInitialDelay =\n    ((options.keepAliveInitialDelay ?? 120000) > socketTimeoutMS\n      ? Math.round(socketTimeoutMS / 2)\n      : options.keepAliveInitialDelay) ?? 120000;\n\n  let socket: Stream;\n  const callback: Callback<Stream> = function (err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  if (useTLS) {\n    const tlsSocket = tls.connect(parseSslOptions(options));\n    if (typeof tlsSocket.disableRenegotiation === 'function') {\n      tlsSocket.disableRenegotiation();\n    }\n    socket = tlsSocket;\n  } else {\n    socket = net.createConnection(parseConnectOptions(options));\n  }\n\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectionTimeout);\n  socket.setNoDelay(noDelay);\n\n  const connectEvent = useTLS ? 'secureConnect' : 'connect';\n  let cancellationHandler: (err: Error) => void;\n  function errorHandler(eventName: ErrorHandlerEventName) {\n    return (err: Error) => {\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n      if (cancellationHandler && options.cancellationToken) {\n        options.cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n    if (cancellationHandler && options.cancellationToken) {\n      options.cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n\n    if ('authorizationError' in socket) {\n      if (socket.authorizationError && rejectUnauthorized) {\n        return callback(socket.authorizationError);\n      }\n    }\n\n    socket.setTimeout(socketTimeoutMS);\n    callback(undefined, socket);\n  }\n\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n  if (options.cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    options.cancellationToken.once('cancel', cancellationHandler);\n  }\n\n  socket.once(connectEvent, connectHandler);\n}\n\nfunction connectionFailureError(type: string, err: Error) {\n  switch (type) {\n    case 'error':\n      return new MongoNetworkError(err);\n    case 'timeout':\n      return new MongoNetworkTimeoutError('connection timed out');\n    case 'close':\n      return new MongoNetworkError('connection closed');\n    case 'cancel':\n      return new MongoNetworkError('connection establishment was cancelled');\n    default:\n      return new MongoNetworkError('unknown network error');\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}