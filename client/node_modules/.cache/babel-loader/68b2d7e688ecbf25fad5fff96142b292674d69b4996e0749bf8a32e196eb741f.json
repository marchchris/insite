{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executeOperation = void 0;\nconst read_preference_1 = require(\"../read_preference\");\nconst error_1 = require(\"../error\");\nconst operation_1 = require(\"./operation\");\nconst utils_1 = require(\"../utils\");\nconst utils_2 = require(\"../utils\");\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\nfunction executeOperation(topology, operation, callback) {\n  if (!(operation instanceof operation_1.AbstractOperation)) {\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n  }\n  return (0, utils_1.maybePromise)(callback, cb => {\n    if (topology.shouldCheckForSessionSupport()) {\n      return topology.selectServer(read_preference_1.ReadPreference.primaryPreferred, err => {\n        if (err) return cb(err);\n        executeOperation(topology, operation, cb);\n      });\n    }\n    // The driver sessions spec mandates that we implicitly create sessions for operations\n    // that are not explicitly provided with a session.\n    let session = operation.session;\n    let owner;\n    if (topology.hasSessionSupport()) {\n      if (session == null) {\n        owner = Symbol();\n        session = topology.startSession({\n          owner,\n          explicit: false\n        });\n      } else if (session.hasEnded) {\n        return cb(new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted'));\n      } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n        return cb(new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later'));\n      }\n    } else if (session) {\n      // If the user passed an explicit session and we are still, after server selection,\n      // trying to run against a topology that doesn't support sessions we error out.\n      return cb(new error_1.MongoCompatibilityError('Current topology does not support sessions'));\n    }\n    try {\n      executeWithServerSelection(topology, session, operation, (err, result) => {\n        if (session && session.owner && session.owner === owner) {\n          return session.endSession(err2 => cb(err2 || err, result));\n        }\n        cb(err, result);\n      });\n    } catch (e) {\n      if (session && session.owner && session.owner === owner) {\n        session.endSession();\n      }\n      throw e;\n    }\n  });\n}\nexports.executeOperation = executeOperation;\nfunction supportsRetryableReads(server) {\n  return (0, utils_1.maxWireVersion)(server) >= 6;\n}\nfunction executeWithServerSelection(topology, session, operation, callback) {\n  const readPreference = operation.readPreference || read_preference_1.ReadPreference.primary;\n  const inTransaction = session && session.inTransaction();\n  if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary)) {\n    callback(new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n    return;\n  }\n  if (session && session.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n  const serverSelectionOptions = {\n    session\n  };\n  function callbackWithRetry(err, result) {\n    if (err == null) {\n      return callback(undefined, result);\n    }\n    const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n    const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n    const itShouldRetryWrite = shouldRetryWrite(err);\n    if (hasReadAspect && !(0, error_1.isRetryableError)(err) || hasWriteAspect && !itShouldRetryWrite) {\n      return callback(err);\n    }\n    if (hasWriteAspect && itShouldRetryWrite && err.code === MMAPv1_RETRY_WRITES_ERROR_CODE && err.errmsg.match(/Transaction numbers/)) {\n      callback(new error_1.MongoServerError({\n        message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n        errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n        originalError: err\n      }));\n      return;\n    }\n    // select a new server, and attempt to retry the operation\n    topology.selectServer(readPreference, serverSelectionOptions, (e, server) => {\n      if (e || operation.hasAspect(operation_1.Aspect.READ_OPERATION) && !supportsRetryableReads(server) || operation.hasAspect(operation_1.Aspect.WRITE_OPERATION) && !(0, utils_2.supportsRetryableWrites)(server)) {\n        callback(e);\n        return;\n      }\n      // If we have a cursor and the initial command fails with a network error,\n      // we can retry it on another connection. So we need to check it back in, clear the\n      // pool for the service id, and retry again.\n      if (err && err instanceof error_1.MongoNetworkError && server.loadBalanced && session && session.isPinned && !session.inTransaction() && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {\n        session.unpin({\n          force: true,\n          forceClear: true\n        });\n      }\n      operation.execute(server, session, callback);\n    });\n  }\n  if (readPreference && !readPreference.equals(read_preference_1.ReadPreference.primary) && session && session.inTransaction()) {\n    callback(new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n    return;\n  }\n  // select a server, and execute the operation against it\n  topology.selectServer(readPreference, serverSelectionOptions, (err, server) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (session && operation.hasAspect(operation_1.Aspect.RETRYABLE)) {\n      const willRetryRead = topology.s.options.retryReads !== false && !inTransaction && supportsRetryableReads(server) && operation.canRetryRead;\n      const willRetryWrite = topology.s.options.retryWrites === true && !inTransaction && (0, utils_2.supportsRetryableWrites)(server) && operation.canRetryWrite;\n      const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n      const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n      if (hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite) {\n        if (hasWriteAspect && willRetryWrite) {\n          operation.options.willRetryWrite = true;\n          session.incrementTransactionNumber();\n        }\n        operation.execute(server, session, callbackWithRetry);\n        return;\n      }\n    }\n    operation.execute(server, session, callback);\n  });\n}\nfunction shouldRetryWrite(err) {\n  return err instanceof error_1.MongoError && err.hasErrorLabel('RetryableWriteError');\n}","map":{"version":3,"names":["read_preference_1","require","error_1","operation_1","utils_1","utils_2","MMAPv1_RETRY_WRITES_ERROR_CODE","MONGODB_ERROR_CODES","IllegalOperation","MMAPv1_RETRY_WRITES_ERROR_MESSAGE","executeOperation","topology","operation","callback","AbstractOperation","MongoRuntimeError","maybePromise","cb","shouldCheckForSessionSupport","selectServer","ReadPreference","primaryPreferred","err","session","owner","hasSessionSupport","Symbol","startSession","explicit","hasEnded","MongoExpiredSessionError","snapshotEnabled","capabilities","supportsSnapshotReads","MongoCompatibilityError","executeWithServerSelection","result","endSession","err2","e","exports","supportsRetryableReads","server","maxWireVersion","readPreference","primary","inTransaction","equals","MongoTransactionError","mode","isPinned","transaction","isCommitted","bypassPinningCheck","unpin","serverSelectionOptions","callbackWithRetry","undefined","hasReadAspect","hasAspect","Aspect","READ_OPERATION","hasWriteAspect","WRITE_OPERATION","itShouldRetryWrite","shouldRetryWrite","isRetryableError","code","errmsg","match","MongoServerError","message","originalError","supportsRetryableWrites","MongoNetworkError","loadBalanced","CURSOR_CREATING","force","forceClear","execute","RETRYABLE","willRetryRead","s","options","retryReads","canRetryRead","willRetryWrite","retryWrites","canRetryWrite","incrementTransactionNumber","MongoError","hasErrorLabel"],"sources":["C:\\Users\\chris\\Desktop\\insite\\node_modules\\mongodb\\src\\operations\\execute_operation.ts"],"sourcesContent":["import { ReadPreference } from '../read_preference';\nimport {\n  MongoError,\n  isRetryableError,\n  MONGODB_ERROR_CODES,\n  MongoRuntimeError,\n  MongoNetworkError,\n  MongoCompatibilityError,\n  MongoServerError,\n  MongoExpiredSessionError,\n  MongoTransactionError\n} from '../error';\nimport { Aspect, AbstractOperation } from './operation';\nimport { maxWireVersion, maybePromise, Callback } from '../utils';\nimport type { Server } from '../sdam/server';\nimport type { Topology } from '../sdam/topology';\nimport type { ClientSession } from '../sessions';\nimport type { Document } from '../bson';\nimport { supportsRetryableWrites } from '../utils';\n\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE =\n  'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\ntype ResultTypeFromOperation<TOperation> = TOperation extends AbstractOperation<infer K>\n  ? K\n  : never;\n\n/** @internal */\nexport interface ExecutionResult {\n  /** The server selected for the operation */\n  server: Server;\n  /** The session used for this operation, may be implicitly created */\n  session?: ClientSession;\n  /** The raw server response for the operation */\n  response: Document;\n}\n\n/**\n * Executes the given operation with provided arguments.\n * @internal\n *\n * @remarks\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param topology - The topology to execute this operation on\n * @param operation - The operation to execute\n * @param callback - The command result callback\n */\nexport function executeOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(topology: Topology, operation: T): Promise<TResult>;\nexport function executeOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(topology: Topology, operation: T, callback: Callback<TResult>): void;\nexport function executeOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(topology: Topology, operation: T, callback?: Callback<TResult>): Promise<TResult> | void;\nexport function executeOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(topology: Topology, operation: T, callback?: Callback<TResult>): Promise<TResult> | void {\n  if (!(operation instanceof AbstractOperation)) {\n    // TODO(NODE-3483)\n    throw new MongoRuntimeError('This method requires a valid operation instance');\n  }\n\n  return maybePromise(callback, cb => {\n    if (topology.shouldCheckForSessionSupport()) {\n      return topology.selectServer(ReadPreference.primaryPreferred, err => {\n        if (err) return cb(err);\n\n        executeOperation<T, TResult>(topology, operation, cb);\n      });\n    }\n\n    // The driver sessions spec mandates that we implicitly create sessions for operations\n    // that are not explicitly provided with a session.\n    let session: ClientSession | undefined = operation.session;\n    let owner: symbol | undefined;\n    if (topology.hasSessionSupport()) {\n      if (session == null) {\n        owner = Symbol();\n        session = topology.startSession({ owner, explicit: false });\n      } else if (session.hasEnded) {\n        return cb(new MongoExpiredSessionError('Use of expired sessions is not permitted'));\n      } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n        return cb(new MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later'));\n      }\n    } else if (session) {\n      // If the user passed an explicit session and we are still, after server selection,\n      // trying to run against a topology that doesn't support sessions we error out.\n      return cb(new MongoCompatibilityError('Current topology does not support sessions'));\n    }\n\n    try {\n      executeWithServerSelection(topology, session, operation, (err, result) => {\n        if (session && session.owner && session.owner === owner) {\n          return session.endSession(err2 => cb(err2 || err, result));\n        }\n\n        cb(err, result);\n      });\n    } catch (e) {\n      if (session && session.owner && session.owner === owner) {\n        session.endSession();\n      }\n\n      throw e;\n    }\n  });\n}\n\nfunction supportsRetryableReads(server: Server) {\n  return maxWireVersion(server) >= 6;\n}\n\nfunction executeWithServerSelection(\n  topology: Topology,\n  session: ClientSession,\n  operation: AbstractOperation,\n  callback: Callback\n) {\n  const readPreference = operation.readPreference || ReadPreference.primary;\n  const inTransaction = session && session.inTransaction();\n\n  if (inTransaction && !readPreference.equals(ReadPreference.primary)) {\n    callback(\n      new MongoTransactionError(\n        `Read preference in a transaction must be primary, not: ${readPreference.mode}`\n      )\n    );\n\n    return;\n  }\n\n  if (\n    session &&\n    session.isPinned &&\n    session.transaction.isCommitted &&\n    !operation.bypassPinningCheck\n  ) {\n    session.unpin();\n  }\n\n  const serverSelectionOptions = { session };\n  function callbackWithRetry(err?: any, result?: any) {\n    if (err == null) {\n      return callback(undefined, result);\n    }\n\n    const hasReadAspect = operation.hasAspect(Aspect.READ_OPERATION);\n    const hasWriteAspect = operation.hasAspect(Aspect.WRITE_OPERATION);\n    const itShouldRetryWrite = shouldRetryWrite(err);\n\n    if ((hasReadAspect && !isRetryableError(err)) || (hasWriteAspect && !itShouldRetryWrite)) {\n      return callback(err);\n    }\n\n    if (\n      hasWriteAspect &&\n      itShouldRetryWrite &&\n      err.code === MMAPv1_RETRY_WRITES_ERROR_CODE &&\n      err.errmsg.match(/Transaction numbers/)\n    ) {\n      callback(\n        new MongoServerError({\n          message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          originalError: err\n        })\n      );\n\n      return;\n    }\n\n    // select a new server, and attempt to retry the operation\n    topology.selectServer(readPreference, serverSelectionOptions, (e?: any, server?: any) => {\n      if (\n        e ||\n        (operation.hasAspect(Aspect.READ_OPERATION) && !supportsRetryableReads(server)) ||\n        (operation.hasAspect(Aspect.WRITE_OPERATION) && !supportsRetryableWrites(server))\n      ) {\n        callback(e);\n        return;\n      }\n\n      // If we have a cursor and the initial command fails with a network error,\n      // we can retry it on another connection. So we need to check it back in, clear the\n      // pool for the service id, and retry again.\n      if (\n        err &&\n        err instanceof MongoNetworkError &&\n        server.loadBalanced &&\n        session &&\n        session.isPinned &&\n        !session.inTransaction() &&\n        operation.hasAspect(Aspect.CURSOR_CREATING)\n      ) {\n        session.unpin({ force: true, forceClear: true });\n      }\n\n      operation.execute(server, session, callback);\n    });\n  }\n\n  if (\n    readPreference &&\n    !readPreference.equals(ReadPreference.primary) &&\n    session &&\n    session.inTransaction()\n  ) {\n    callback(\n      new MongoTransactionError(\n        `Read preference in a transaction must be primary, not: ${readPreference.mode}`\n      )\n    );\n\n    return;\n  }\n\n  // select a server, and execute the operation against it\n  topology.selectServer(readPreference, serverSelectionOptions, (err?: any, server?: any) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (session && operation.hasAspect(Aspect.RETRYABLE)) {\n      const willRetryRead =\n        topology.s.options.retryReads !== false &&\n        !inTransaction &&\n        supportsRetryableReads(server) &&\n        operation.canRetryRead;\n\n      const willRetryWrite =\n        topology.s.options.retryWrites === true &&\n        !inTransaction &&\n        supportsRetryableWrites(server) &&\n        operation.canRetryWrite;\n\n      const hasReadAspect = operation.hasAspect(Aspect.READ_OPERATION);\n      const hasWriteAspect = operation.hasAspect(Aspect.WRITE_OPERATION);\n\n      if ((hasReadAspect && willRetryRead) || (hasWriteAspect && willRetryWrite)) {\n        if (hasWriteAspect && willRetryWrite) {\n          operation.options.willRetryWrite = true;\n          session.incrementTransactionNumber();\n        }\n\n        operation.execute(server, session, callbackWithRetry);\n        return;\n      }\n    }\n\n    operation.execute(server, session, callback);\n  });\n}\n\nfunction shouldRetryWrite(err: any) {\n  return err instanceof MongoError && err.hasErrorLabel('RetryableWriteError');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}