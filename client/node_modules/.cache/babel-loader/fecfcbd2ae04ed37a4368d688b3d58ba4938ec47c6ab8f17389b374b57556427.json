{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TopologyDescription = void 0;\nconst server_description_1 = require(\"./server_description\");\nconst WIRE_CONSTANTS = require(\"../cmap/wire_protocol/constants\");\nconst common_1 = require(\"./common\");\nconst error_1 = require(\"../error\");\n// constants related to compatibility checks\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\nconst MONGOS_OR_UNKNOWN = new Set([common_1.ServerType.Mongos, common_1.ServerType.Unknown]);\nconst MONGOS_OR_STANDALONE = new Set([common_1.ServerType.Mongos, common_1.ServerType.Standalone]);\nconst NON_PRIMARY_RS_MEMBERS = new Set([common_1.ServerType.RSSecondary, common_1.ServerType.RSArbiter, common_1.ServerType.RSOther]);\n/**\n * Representation of a deployment of servers\n * @public\n */\nclass TopologyDescription {\n  /**\n   * Create a TopologyDescription\n   */\n  constructor(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options) {\n    var _a, _b;\n    options = options !== null && options !== void 0 ? options : {};\n    // TODO: consider assigning all these values to a temporary value `s` which\n    //       we use `Object.freeze` on, ensuring the internal state of this type\n    //       is immutable.\n    this.type = topologyType !== null && topologyType !== void 0 ? topologyType : common_1.TopologyType.Unknown;\n    this.servers = serverDescriptions !== null && serverDescriptions !== void 0 ? serverDescriptions : new Map();\n    this.stale = false;\n    this.compatible = true;\n    this.heartbeatFrequencyMS = (_a = options.heartbeatFrequencyMS) !== null && _a !== void 0 ? _a : 0;\n    this.localThresholdMS = (_b = options.localThresholdMS) !== null && _b !== void 0 ? _b : 0;\n    if (setName) {\n      this.setName = setName;\n    }\n    if (maxSetVersion) {\n      this.maxSetVersion = maxSetVersion;\n    }\n    if (maxElectionId) {\n      this.maxElectionId = maxElectionId;\n    }\n    if (commonWireVersion) {\n      this.commonWireVersion = commonWireVersion;\n    }\n    // determine server compatibility\n    for (const serverDescription of this.servers.values()) {\n      // Load balancer mode is always compatible.\n      if (serverDescription.type === common_1.ServerType.Unknown || serverDescription.type === common_1.ServerType.LoadBalancer) {\n        continue;\n      }\n      if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n      }\n      if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\n        break;\n      }\n    }\n    // Whenever a client updates the TopologyDescription from an ismaster response, it MUST set\n    // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n    // value among ServerDescriptions of all data-bearing server types. If any have a null\n    // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n    // set to null.\n    this.logicalSessionTimeoutMinutes = undefined;\n    for (const [, server] of this.servers) {\n      if (server.isReadable) {\n        if (server.logicalSessionTimeoutMinutes == null) {\n          // If any of the servers have a null logicalSessionsTimeout, then the whole topology does\n          this.logicalSessionTimeoutMinutes = undefined;\n          break;\n        }\n        if (this.logicalSessionTimeoutMinutes == null) {\n          // First server with a non null logicalSessionsTimeout\n          this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;\n          continue;\n        }\n        // Always select the smaller of the:\n        // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout\n        this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);\n      }\n    }\n  }\n  /**\n   * Returns a new TopologyDescription based on the SrvPollingEvent\n   * @internal\n   */\n  updateFromSrvPollingEvent(ev) {\n    const newAddresses = ev.addresses();\n    const serverDescriptions = new Map(this.servers);\n    for (const address of this.servers.keys()) {\n      if (newAddresses.has(address)) {\n        newAddresses.delete(address);\n      } else {\n        serverDescriptions.delete(address);\n      }\n    }\n    if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {\n      return this;\n    }\n    for (const [address, host] of newAddresses) {\n      serverDescriptions.set(address, new server_description_1.ServerDescription(host));\n    }\n    return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, {\n      heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n      localThresholdMS: this.localThresholdMS\n    });\n  }\n  /**\n   * Returns a copy of this description updated with a given ServerDescription\n   * @internal\n   */\n  update(serverDescription) {\n    const address = serverDescription.address;\n    // potentially mutated values\n    let {\n      type: topologyType,\n      setName,\n      maxSetVersion,\n      maxElectionId,\n      commonWireVersion\n    } = this;\n    if (serverDescription.setName && setName && serverDescription.setName !== setName) {\n      serverDescription = new server_description_1.ServerDescription(address, undefined);\n    }\n    const serverType = serverDescription.type;\n    const serverDescriptions = new Map(this.servers);\n    // update common wire version\n    if (serverDescription.maxWireVersion !== 0) {\n      if (commonWireVersion == null) {\n        commonWireVersion = serverDescription.maxWireVersion;\n      } else {\n        commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n      }\n    }\n    // update the actual server description\n    serverDescriptions.set(address, serverDescription);\n    if (topologyType === common_1.TopologyType.Single) {\n      // once we are defined as single, that never changes\n      return new TopologyDescription(common_1.TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, {\n        heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n        localThresholdMS: this.localThresholdMS\n      });\n    }\n    if (topologyType === common_1.TopologyType.Unknown) {\n      if (serverType === common_1.ServerType.Standalone && this.servers.size !== 1) {\n        serverDescriptions.delete(address);\n      } else {\n        topologyType = topologyTypeForServerType(serverType);\n      }\n    }\n    if (topologyType === common_1.TopologyType.Sharded) {\n      if (!MONGOS_OR_UNKNOWN.has(serverType)) {\n        serverDescriptions.delete(address);\n      }\n    }\n    if (topologyType === common_1.TopologyType.ReplicaSetNoPrimary) {\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\n        serverDescriptions.delete(address);\n      }\n      if (serverType === common_1.ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);\n        topologyType = result[0];\n        setName = result[1];\n        maxSetVersion = result[2];\n        maxElectionId = result[3];\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n        const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);\n        topologyType = result[0];\n        setName = result[1];\n      }\n    }\n    if (topologyType === common_1.TopologyType.ReplicaSetWithPrimary) {\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\n        serverDescriptions.delete(address);\n        topologyType = checkHasPrimary(serverDescriptions);\n      } else if (serverType === common_1.ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);\n        topologyType = result[0];\n        setName = result[1];\n        maxSetVersion = result[2];\n        maxElectionId = result[3];\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n        topologyType = updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName);\n      } else {\n        topologyType = checkHasPrimary(serverDescriptions);\n      }\n    }\n    return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, {\n      heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n      localThresholdMS: this.localThresholdMS\n    });\n  }\n  get error() {\n    const descriptionsWithError = Array.from(this.servers.values()).filter(sd => sd.error);\n    if (descriptionsWithError.length > 0) {\n      return descriptionsWithError[0].error;\n    }\n  }\n  /**\n   * Determines if the topology description has any known servers\n   */\n  get hasKnownServers() {\n    return Array.from(this.servers.values()).some(sd => sd.type !== common_1.ServerType.Unknown);\n  }\n  /**\n   * Determines if this topology description has a data-bearing server available.\n   */\n  get hasDataBearingServers() {\n    return Array.from(this.servers.values()).some(sd => sd.isDataBearing);\n  }\n  /**\n   * Determines if the topology has a definition for the provided address\n   * @internal\n   */\n  hasServer(address) {\n    return this.servers.has(address);\n  }\n}\nexports.TopologyDescription = TopologyDescription;\nfunction topologyTypeForServerType(serverType) {\n  switch (serverType) {\n    case common_1.ServerType.Standalone:\n      return common_1.TopologyType.Single;\n    case common_1.ServerType.Mongos:\n      return common_1.TopologyType.Sharded;\n    case common_1.ServerType.RSPrimary:\n      return common_1.TopologyType.ReplicaSetWithPrimary;\n    case common_1.ServerType.RSOther:\n    case common_1.ServerType.RSSecondary:\n      return common_1.TopologyType.ReplicaSetNoPrimary;\n    default:\n      return common_1.TopologyType.Unknown;\n  }\n}\n// TODO: improve these docs when ObjectId is properly typed\nfunction compareObjectId(oid1, oid2) {\n  if (oid1 == null) {\n    return -1;\n  }\n  if (oid2 == null) {\n    return 1;\n  }\n  if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {\n    const oid1Buffer = oid1.id;\n    const oid2Buffer = oid2.id;\n    return oid1Buffer.compare(oid2Buffer);\n  }\n  const oid1String = oid1.toString();\n  const oid2String = oid2.toString();\n  return oid1String.localeCompare(oid2String);\n}\nfunction updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId) {\n  setName = setName || serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n  }\n  const electionId = serverDescription.electionId ? serverDescription.electionId : null;\n  if (serverDescription.setVersion && electionId) {\n    if (maxSetVersion && maxElectionId) {\n      if (maxSetVersion > serverDescription.setVersion || compareObjectId(maxElectionId, electionId) > 0) {\n        // this primary is stale, we must remove it\n        serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));\n        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n      }\n    }\n    maxElectionId = serverDescription.electionId;\n  }\n  if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {\n    maxSetVersion = serverDescription.setVersion;\n  }\n  // We've heard from the primary. Is it the same primary as before?\n  for (const [address, server] of serverDescriptions) {\n    if (server.type === common_1.ServerType.RSPrimary && server.address !== serverDescription.address) {\n      // Reset old primary's type to Unknown.\n      serverDescriptions.set(address, new server_description_1.ServerDescription(server.address));\n      // There can only be one primary\n      break;\n    }\n  }\n  // Discover new hosts from this primary's response.\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new server_description_1.ServerDescription(address));\n    }\n  });\n  // Remove hosts not in the response.\n  const currentAddresses = Array.from(serverDescriptions.keys());\n  const responseAddresses = serverDescription.allHosts;\n  currentAddresses.filter(addr => responseAddresses.indexOf(addr) === -1).forEach(address => {\n    serverDescriptions.delete(address);\n  });\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\nfunction updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName) {\n  if (setName == null) {\n    // TODO(NODE-3483): should be an appropriate runtime error\n    throw new error_1.MongoRuntimeError('Argument \"setName\" is required if connected to a replica set');\n  }\n  if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n  return checkHasPrimary(serverDescriptions);\n}\nfunction updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName) {\n  const topologyType = common_1.TopologyType.ReplicaSetNoPrimary;\n  setName = setName || serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [topologyType, setName];\n  }\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new server_description_1.ServerDescription(address));\n    }\n  });\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n  return [topologyType, setName];\n}\nfunction checkHasPrimary(serverDescriptions) {\n  for (const serverDescription of serverDescriptions.values()) {\n    if (serverDescription.type === common_1.ServerType.RSPrimary) {\n      return common_1.TopologyType.ReplicaSetWithPrimary;\n    }\n  }\n  return common_1.TopologyType.ReplicaSetNoPrimary;\n}","map":{"version":3,"names":["server_description_1","require","WIRE_CONSTANTS","common_1","error_1","MIN_SUPPORTED_SERVER_VERSION","MAX_SUPPORTED_SERVER_VERSION","MIN_SUPPORTED_WIRE_VERSION","MAX_SUPPORTED_WIRE_VERSION","MONGOS_OR_UNKNOWN","Set","ServerType","Mongos","Unknown","MONGOS_OR_STANDALONE","Standalone","NON_PRIMARY_RS_MEMBERS","RSSecondary","RSArbiter","RSOther","TopologyDescription","constructor","topologyType","serverDescriptions","setName","maxSetVersion","maxElectionId","commonWireVersion","options","type","TopologyType","servers","Map","stale","compatible","heartbeatFrequencyMS","_a","localThresholdMS","_b","serverDescription","values","LoadBalancer","minWireVersion","compatibilityError","address","maxWireVersion","logicalSessionTimeoutMinutes","undefined","server","isReadable","Math","min","updateFromSrvPollingEvent","ev","newAddresses","addresses","keys","has","delete","size","host","set","ServerDescription","update","serverType","Single","topologyTypeForServerType","Sharded","ReplicaSetNoPrimary","RSPrimary","result","updateRsFromPrimary","updateRsNoPrimaryFromMember","ReplicaSetWithPrimary","checkHasPrimary","updateRsWithPrimaryFromMember","error","descriptionsWithError","Array","from","filter","sd","length","hasKnownServers","some","hasDataBearingServers","isDataBearing","hasServer","exports","compareObjectId","oid1","oid2","id","Buffer","oid1Buffer","oid2Buffer","compare","oid1String","toString","oid2String","localeCompare","electionId","setVersion","allHosts","forEach","currentAddresses","responseAddresses","addr","indexOf","MongoRuntimeError","me"],"sources":["C:\\Users\\chris\\Desktop\\insite\\node_modules\\mongodb\\src\\sdam\\topology_description.ts"],"sourcesContent":["import { ServerDescription } from './server_description';\nimport * as WIRE_CONSTANTS from '../cmap/wire_protocol/constants';\nimport { TopologyType, ServerType } from './common';\nimport type { ObjectId, Document } from '../bson';\nimport type { SrvPollingEvent } from './srv_polling';\nimport { MongoError, MongoRuntimeError } from '../error';\n\n// constants related to compatibility checks\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\n\nconst MONGOS_OR_UNKNOWN = new Set<ServerType>([ServerType.Mongos, ServerType.Unknown]);\nconst MONGOS_OR_STANDALONE = new Set<ServerType>([ServerType.Mongos, ServerType.Standalone]);\nconst NON_PRIMARY_RS_MEMBERS = new Set<ServerType>([\n  ServerType.RSSecondary,\n  ServerType.RSArbiter,\n  ServerType.RSOther\n]);\n\n/** @public */\nexport interface TopologyDescriptionOptions {\n  heartbeatFrequencyMS?: number;\n  localThresholdMS?: number;\n}\n\n/**\n * Representation of a deployment of servers\n * @public\n */\nexport class TopologyDescription {\n  type: TopologyType;\n  setName?: string;\n  maxSetVersion?: number;\n  maxElectionId?: ObjectId;\n  servers: Map<string, ServerDescription>;\n  stale: boolean;\n  compatible: boolean;\n  compatibilityError?: string;\n  logicalSessionTimeoutMinutes?: number;\n  heartbeatFrequencyMS: number;\n  localThresholdMS: number;\n  commonWireVersion?: number;\n\n  /**\n   * Create a TopologyDescription\n   */\n  constructor(\n    topologyType: TopologyType,\n    serverDescriptions?: Map<string, ServerDescription>,\n    setName?: string,\n    maxSetVersion?: number,\n    maxElectionId?: ObjectId,\n    commonWireVersion?: number,\n    options?: TopologyDescriptionOptions\n  ) {\n    options = options ?? {};\n\n    // TODO: consider assigning all these values to a temporary value `s` which\n    //       we use `Object.freeze` on, ensuring the internal state of this type\n    //       is immutable.\n    this.type = topologyType ?? TopologyType.Unknown;\n    this.servers = serverDescriptions ?? new Map();\n    this.stale = false;\n    this.compatible = true;\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 0;\n    this.localThresholdMS = options.localThresholdMS ?? 0;\n\n    if (setName) {\n      this.setName = setName;\n    }\n\n    if (maxSetVersion) {\n      this.maxSetVersion = maxSetVersion;\n    }\n\n    if (maxElectionId) {\n      this.maxElectionId = maxElectionId;\n    }\n\n    if (commonWireVersion) {\n      this.commonWireVersion = commonWireVersion;\n    }\n\n    // determine server compatibility\n    for (const serverDescription of this.servers.values()) {\n      // Load balancer mode is always compatible.\n      if (\n        serverDescription.type === ServerType.Unknown ||\n        serverDescription.type === ServerType.LoadBalancer\n      ) {\n        continue;\n      }\n\n      if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n      }\n\n      if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\n        break;\n      }\n    }\n\n    // Whenever a client updates the TopologyDescription from an ismaster response, it MUST set\n    // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n    // value among ServerDescriptions of all data-bearing server types. If any have a null\n    // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n    // set to null.\n    this.logicalSessionTimeoutMinutes = undefined;\n    for (const [, server] of this.servers) {\n      if (server.isReadable) {\n        if (server.logicalSessionTimeoutMinutes == null) {\n          // If any of the servers have a null logicalSessionsTimeout, then the whole topology does\n          this.logicalSessionTimeoutMinutes = undefined;\n          break;\n        }\n\n        if (this.logicalSessionTimeoutMinutes == null) {\n          // First server with a non null logicalSessionsTimeout\n          this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;\n          continue;\n        }\n\n        // Always select the smaller of the:\n        // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout\n        this.logicalSessionTimeoutMinutes = Math.min(\n          this.logicalSessionTimeoutMinutes,\n          server.logicalSessionTimeoutMinutes\n        );\n      }\n    }\n  }\n\n  /**\n   * Returns a new TopologyDescription based on the SrvPollingEvent\n   * @internal\n   */\n  updateFromSrvPollingEvent(ev: SrvPollingEvent): TopologyDescription {\n    const newAddresses = ev.addresses();\n    const serverDescriptions = new Map(this.servers);\n    for (const address of this.servers.keys()) {\n      if (newAddresses.has(address)) {\n        newAddresses.delete(address);\n      } else {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {\n      return this;\n    }\n\n    for (const [address, host] of newAddresses) {\n      serverDescriptions.set(address, new ServerDescription(host));\n    }\n\n    return new TopologyDescription(\n      this.type,\n      serverDescriptions,\n      this.setName,\n      this.maxSetVersion,\n      this.maxElectionId,\n      this.commonWireVersion,\n      { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS }\n    );\n  }\n\n  /**\n   * Returns a copy of this description updated with a given ServerDescription\n   * @internal\n   */\n  update(serverDescription: ServerDescription): TopologyDescription {\n    const address = serverDescription.address;\n\n    // potentially mutated values\n    let { type: topologyType, setName, maxSetVersion, maxElectionId, commonWireVersion } = this;\n\n    if (serverDescription.setName && setName && serverDescription.setName !== setName) {\n      serverDescription = new ServerDescription(address, undefined);\n    }\n\n    const serverType = serverDescription.type;\n    const serverDescriptions = new Map(this.servers);\n\n    // update common wire version\n    if (serverDescription.maxWireVersion !== 0) {\n      if (commonWireVersion == null) {\n        commonWireVersion = serverDescription.maxWireVersion;\n      } else {\n        commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n      }\n    }\n\n    // update the actual server description\n    serverDescriptions.set(address, serverDescription);\n\n    if (topologyType === TopologyType.Single) {\n      // once we are defined as single, that never changes\n      return new TopologyDescription(\n        TopologyType.Single,\n        serverDescriptions,\n        setName,\n        maxSetVersion,\n        maxElectionId,\n        commonWireVersion,\n        { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS }\n      );\n    }\n\n    if (topologyType === TopologyType.Unknown) {\n      if (serverType === ServerType.Standalone && this.servers.size !== 1) {\n        serverDescriptions.delete(address);\n      } else {\n        topologyType = topologyTypeForServerType(serverType);\n      }\n    }\n\n    if (topologyType === TopologyType.Sharded) {\n      if (!MONGOS_OR_UNKNOWN.has(serverType)) {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetNoPrimary) {\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\n        serverDescriptions.delete(address);\n      }\n\n      if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(\n          serverDescriptions,\n          serverDescription,\n          setName,\n          maxSetVersion,\n          maxElectionId\n        );\n\n        topologyType = result[0];\n        setName = result[1];\n        maxSetVersion = result[2];\n        maxElectionId = result[3];\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n        const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);\n        topologyType = result[0];\n        setName = result[1];\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetWithPrimary) {\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\n        serverDescriptions.delete(address);\n        topologyType = checkHasPrimary(serverDescriptions);\n      } else if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(\n          serverDescriptions,\n          serverDescription,\n          setName,\n          maxSetVersion,\n          maxElectionId\n        );\n\n        topologyType = result[0];\n        setName = result[1];\n        maxSetVersion = result[2];\n        maxElectionId = result[3];\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n        topologyType = updateRsWithPrimaryFromMember(\n          serverDescriptions,\n          serverDescription,\n          setName\n        );\n      } else {\n        topologyType = checkHasPrimary(serverDescriptions);\n      }\n    }\n\n    return new TopologyDescription(\n      topologyType,\n      serverDescriptions,\n      setName,\n      maxSetVersion,\n      maxElectionId,\n      commonWireVersion,\n      { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS }\n    );\n  }\n\n  get error(): MongoError | undefined {\n    const descriptionsWithError = Array.from(this.servers.values()).filter(\n      (sd: ServerDescription) => sd.error\n    );\n\n    if (descriptionsWithError.length > 0) {\n      return descriptionsWithError[0].error;\n    }\n  }\n\n  /**\n   * Determines if the topology description has any known servers\n   */\n  get hasKnownServers(): boolean {\n    return Array.from(this.servers.values()).some(\n      (sd: ServerDescription) => sd.type !== ServerType.Unknown\n    );\n  }\n\n  /**\n   * Determines if this topology description has a data-bearing server available.\n   */\n  get hasDataBearingServers(): boolean {\n    return Array.from(this.servers.values()).some((sd: ServerDescription) => sd.isDataBearing);\n  }\n\n  /**\n   * Determines if the topology has a definition for the provided address\n   * @internal\n   */\n  hasServer(address: string): boolean {\n    return this.servers.has(address);\n  }\n}\n\nfunction topologyTypeForServerType(serverType: ServerType): TopologyType {\n  switch (serverType) {\n    case ServerType.Standalone:\n      return TopologyType.Single;\n    case ServerType.Mongos:\n      return TopologyType.Sharded;\n    case ServerType.RSPrimary:\n      return TopologyType.ReplicaSetWithPrimary;\n    case ServerType.RSOther:\n    case ServerType.RSSecondary:\n      return TopologyType.ReplicaSetNoPrimary;\n    default:\n      return TopologyType.Unknown;\n  }\n}\n\n// TODO: improve these docs when ObjectId is properly typed\nfunction compareObjectId(oid1: Document, oid2: Document): number {\n  if (oid1 == null) {\n    return -1;\n  }\n\n  if (oid2 == null) {\n    return 1;\n  }\n\n  if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {\n    const oid1Buffer = oid1.id;\n    const oid2Buffer = oid2.id;\n    return oid1Buffer.compare(oid2Buffer);\n  }\n\n  const oid1String = oid1.toString();\n  const oid2String = oid2.toString();\n  return oid1String.localeCompare(oid2String);\n}\n\nfunction updateRsFromPrimary(\n  serverDescriptions: Map<string, ServerDescription>,\n  serverDescription: ServerDescription,\n  setName?: string,\n  maxSetVersion?: number,\n  maxElectionId?: ObjectId\n): [TopologyType, string?, number?, ObjectId?] {\n  setName = setName || serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n  }\n\n  const electionId = serverDescription.electionId ? serverDescription.electionId : null;\n  if (serverDescription.setVersion && electionId) {\n    if (maxSetVersion && maxElectionId) {\n      if (\n        maxSetVersion > serverDescription.setVersion ||\n        compareObjectId(maxElectionId, electionId) > 0\n      ) {\n        // this primary is stale, we must remove it\n        serverDescriptions.set(\n          serverDescription.address,\n          new ServerDescription(serverDescription.address)\n        );\n\n        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n      }\n    }\n\n    maxElectionId = serverDescription.electionId;\n  }\n\n  if (\n    serverDescription.setVersion != null &&\n    (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)\n  ) {\n    maxSetVersion = serverDescription.setVersion;\n  }\n\n  // We've heard from the primary. Is it the same primary as before?\n  for (const [address, server] of serverDescriptions) {\n    if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {\n      // Reset old primary's type to Unknown.\n      serverDescriptions.set(address, new ServerDescription(server.address));\n\n      // There can only be one primary\n      break;\n    }\n  }\n\n  // Discover new hosts from this primary's response.\n  serverDescription.allHosts.forEach((address: string) => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  // Remove hosts not in the response.\n  const currentAddresses = Array.from(serverDescriptions.keys());\n  const responseAddresses = serverDescription.allHosts;\n  currentAddresses\n    .filter((addr: string) => responseAddresses.indexOf(addr) === -1)\n    .forEach((address: string) => {\n      serverDescriptions.delete(address);\n    });\n\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\n\nfunction updateRsWithPrimaryFromMember(\n  serverDescriptions: Map<string, ServerDescription>,\n  serverDescription: ServerDescription,\n  setName?: string\n): TopologyType {\n  if (setName == null) {\n    // TODO(NODE-3483): should be an appropriate runtime error\n    throw new MongoRuntimeError('Argument \"setName\" is required if connected to a replica set');\n  }\n\n  if (\n    setName !== serverDescription.setName ||\n    (serverDescription.me && serverDescription.address !== serverDescription.me)\n  ) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return checkHasPrimary(serverDescriptions);\n}\n\nfunction updateRsNoPrimaryFromMember(\n  serverDescriptions: Map<string, ServerDescription>,\n  serverDescription: ServerDescription,\n  setName?: string\n): [TopologyType, string?] {\n  const topologyType = TopologyType.ReplicaSetNoPrimary;\n  setName = setName || serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [topologyType, setName];\n  }\n\n  serverDescription.allHosts.forEach((address: string) => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return [topologyType, setName];\n}\n\nfunction checkHasPrimary(serverDescriptions: Map<string, ServerDescription>): TopologyType {\n  for (const serverDescription of serverDescriptions.values()) {\n    if (serverDescription.type === ServerType.RSPrimary) {\n      return TopologyType.ReplicaSetWithPrimary;\n    }\n  }\n\n  return TopologyType.ReplicaSetNoPrimary;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}